/**
 * @license
 * Copyright (C) 2018 Gnucoop soc. coop.
 *
 * This file is part of the Advanced JSON forms (ajf).
 *
 * Advanced JSON forms (ajf) is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero
 * General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Advanced JSON forms (ajf).
 * If not, see http://www.gnu.org/licenses/.
 *
 */
import { AjfExpressionUtils } from '@ajf/core/models';
import { Injectable } from '@angular/core';
var AjfValidationService = /** @class */ (function () {
    function AjfValidationService() {
        this._baseUtilFunctions = [
            "/**\n        * count the number of digit contained on x.\n        * @param  x the value used for digit count\n        * @return the count of the digit\n      */\n    var digitCount = function(x) { return x.toString().length; }",
            "/**\n        * count the number of decimal contained on x.\n        * @param  x the value used for decimal count\n        * @return the count of the decimal\n      */\n    var decimalCount = function(x) {\n      return (parseFloat(x).toString().split('.')[1] || []).length;\n    }",
            "/**\n        * check if x is integer\n        * @param  x the value used for check\n        * @return true if x is a number\n      */\n    var isInt = function(x) { return !/[,.]/.test(x); }",
            "/**\n        * check if x is not empity\n        * @param  x the value used for check\n        * @return true if x defined and not null and the number of digit is > 0\n      */\n    var notEmpty = function (x) {\n      return (typeof x !== 'undefined' && x !== null ? x.toString().length > 0 : false);\n    }",
            "/**\n        * check if x is contained on array\n        * @param  x the value used for check\n        * @return the position of x on array or if array === x\n      */\n    var valueInChoice = function(array, x) { return array.indexOf(x) > -1 || array === x; }",
            "var scanGroupField = function(reps, acc, callback) {\n        for (var i = 0; i < reps; i++) {\n            acc = callback(acc, i);\n        }\n        return acc;\n    }",
            "/**\n        * sum the value contained on array\n        * @param  x the array\n        * @return the sum\n      */\n    var sum = function(array) {return array.reduce(function(a, b){ return a + b; }, 0); }",
            "var dateOperations = function(dString, period, operation, v) {\n        fmt = 'mm/dd/yyyy';\n        var d = (typeof dString !== 'undefined') ? dateUtils.parse(dString) : new Date();\n        if (operation == 'remove') {\n          v = -v;\n        }\n        var dateOp;\n        switch (period) {\n          case 'day':\n            dateOp = dateUtils.addDays;\n            break;\n          case 'month':\n            dateOp = dateUtils.addMonths;\n            break;\n          case 'year':\n            dateOp = dateUtils.addYears;\n            break;\n          default:\n            return -1;\n        }\n        return dateUtils.format(dateOp(d, v), fmt);\n      }",
            "/**\n        * round the num\n        * @param  num the value to round\n        * @param  digits how many digit\n        * @return num rounded\n      */\n      var round = function(num, digits) {\n        digits = digits || 0;\n        var f = 0;\n        try { f = parseFloat(num); } catch (e) { }\n        var m = Math.pow(10, digits);\n        return Math.round(f * m) / m;\n      }",
            "/**\n        * extract the property of the source object with property != null\n        * @param  source array of object wich contains property\n        * @param  property the property on wich we want filter\n        * @return array of dates\n      */\n      var extractArray = function(source, property, property2) {\n        source = (source || []).slice(0);\n        var l = source.length;\n        var res = [];\n        for (var i = 0; i < l ; i++) {\n          if (source[i][property] != null && source[i][property2] != null) {\n            res.push(source[i][property] + source[i][property2]);\n          }\n          else if (source[i][property] != null) {\n            res.push(source[i][property]);\n          }\n        }\n        return res;\n      }",
            "/**\n        * extract the property of the source object with property != null\n        * @param  source array of object wich contains property\n        * @param  propertues string array the properties to sum\n        * @return the sum\n      */\n      var extractSum = function(source, properties) {\n        var sum = 0;\n        properties = (properties || []).slice(0);\n        var l = properties.length;\n\n        for (var i = 0; i < l ; i++) {\n          var array = extractArray(source, properties[i]);\n          var leng = array.length;\n          for(var j = 0; j < leng; i++) {\n            sum += array[j];\n          }\n        }\n        return sum;\n      }",
            "/**\n        * extract the array of sum for each week != null\n        * @param  source array of object wich contains property\n        * @param  propertues string array the properties to sum\n        * @return the sum\n      */\n      var extractArraySum = function(source, properties) {\n        var arrays = [];\n        properties = (properties || []).slice(0);\n\n        for (var propI = 0; propI < properties.length ; propI++) {\n          var array = extractArray(source, properties[propI]);\n          arrays.push(array);\n        }\n\n        var res = [];\n        for (var weekI = 0; weekI < array.length; weekI ++ ) {\n          var sum = 0;\n          for (var propI = 0; propI < properties.length ; propI++) {\n            sum = sum + arrays[propI][weekI]\n          }\n          res.push(sum);\n        }\n        return res;\n      }",
            "/**\n        * draw a threshold line on chart related to the property\n        * @param  source array of object wich contains property\n        * @param  property the property on wich we want filter\n        * @return array of dates\n      */\n      var drawThreshold = function(source, property, threshold) {\n        source = (source || []).slice(0);\n        var l = source.length;\n        var res = [];\n        for (var i = 0; i < l ; i++) {\n          if (source[i][property] != null) {\n            res.push(threshold);\n          }\n        }\n        return res;\n      }",
            "/**\n        * extract the dates of the source object with property != null\n        * @param  source array of object wich contains property and date_start\n        * @param  property the property on wich we want to calculate dates\n        * @param  format the format of the date\n        * @return array of dates\n      */\n      var extractDates = function(source, property, format) {\n        source = (source || []).slice(0);\n        var l = source.length;\n        var res = [];\n        var prefix = '';\n        for (var i = 0; i < l ; i++) {\n          if (source[i][property] != null) {\n            switch(format) {\n              case \"WW\":\n                prefix = \"W\";\n                break;\n              case \"mm\":\n                prefix = \"M\";\n                break;\n              default:\n                prefix = \"\";\n            }\n            res.push(prefix + formatDate(source[i][\"date_start\"], format));\n          }\n        }\n        return res;\n      }",
            "/**\n        * extract the last property contains in source != null\n        * @param  source array of object wich contains property and date_start\n        * @param  property the property to find\n        * @return the last property != null\n      */\n      var lastProperty = function(source, property) {\n        source = (source || []).slice(0);\n        var l = source.length -1;\n\n        while (l >= 0 && source[l][property] == null) {\n          l--;\n          if (l < 0) return 0;\n        }\n        return l >= 0 ? source[l][property] : 0;\n      }",
            "var sumLastProperties = function(source, properties) {\n        source = (source || []).slice(0);\n        var sum = 0;\n        for (var i = 0; i < properties.length; i++) {\n          sum += lastProperty(source, properties[i]);\n        }\n\n        return sum;\n      }",
            "/**\n        * compute the trend of the property contained on the source.\n        * @param  source array of object wich contains property\n        * @param  property the property on wich we want to calculate the trend\n        * @return an html icon that identifies the trend\n      */\n      var calculateTrendProperty = function(source, property) {\n        source = (source || []).slice(0);\n        var last = source.length - 1;\n        while (source[last][property] == null) {\n          if (last == 0) {\n            break;\n          }\n          last--;\n        }\n        var lastLast = last - 1;\n        if (last == 0) {\n          lastLast = last;\n        } else {\n          while (source[lastLast][property] == null) {\n            if (lastLast == 0) {\n              lastLast = last;\n              break;\n            }\n            lastLast--;\n          }\n        }\n\n        var lastProperty = source[last]?(source[last][property] || 0): 0;\n        var lastLastProperty = source[lastLast]?(source[lastLast][property] || 0): 0;\n\n        if (lastProperty == lastLastProperty) {\n          return '<p><i class=\"material-icons\" style=\"color:blue\">trending_flat</i></p>';\n        } else if (lastProperty > lastLastProperty) {\n          return '<p><i class=\"material-icons\" style=\"color:green\">trending_up</i></p>';\n        } else {\n          return '<p><i class=\"material-icons\" style=\"color:red\">trending_down</i></p>';\n        }\n      }",
            "/**\n        * compute the average value of the property contained on the source.\n        * @param  source array of object wich contains property\n        * @param  property the property on wich we want to calculate the average\n        * @param  range the range on wich we want to calculate the average\n        * @param  coefficent the coefficent used for calculate the threshold\n                  if coefficent is 0 mean return the count of property > 0\n        * @return the average value || the count of property > 0\n      */\n      var calculateAvgProperty = function(source, property, range, coefficient) {\n        source = (source || []).slice(0);\n\n        source.pop();\n\n        coefficient = coefficient || 1;\n        range = range || 12;\n\n        var l = source.length;\n        var res = 0;\n        var counter = 0;\n        var noZero = 0;\n\n        if(l < range) {\n          range = l;\n        }\n\n        while (range != 0) {\n          counter++;\n          if (source[l - 1][property] != null) {\n            res += source[l - 1][property];\n\n            if (source[l - 1][property] > 0) {\n              noZero++;\n            }\n          }\n          l--;\n          range--;\n        }\n\n        if (coefficient == 0) {\n          return noZero;\n        } else {\n          var threshold = (res/counter)*coefficient || 0;\n          return threshold;\n        }\n      }",
            "var alert = function(source, property, threshold, fmt) {\n        source = (source || []).slice(0);\n        var l = source.length;\n\n        if ( lastProperty(source, property)  > threshold ) {\n          return '<p><i class=\"material-icons\" style=\"color:red\">warning</i></p>';\n          } else {\n            return '<p></p>';\n          }\n      }",
            "var formatNumber = function(num, fmt) {\n        fmt = fmt || '0,0[.]0';\n        return numeral(num).format(fmt);\n      }",
            "var formatDate = function(date, fmt) {\n        fmt = fmt || 'mm-dd-yyyy';\n        return dateUtils.format(date, fmt);\n      }",
            "var isoMonth = function(date, fmt) {\n        fmt = fmt || 'mm';\n        var du = dateUtils;\n        return du.format(du.addDays(du.startOfMonth(date), 4),fmt)\n      }",
            "var nextCounterValue = function(counterName, firstValue) {\n        firstValue = firstValue != null ? firstValue : 0;\n        if (execContext['$$'+counterName] == null) {\n          execContext['$$'+counterName] = firstValue;\n        } else {\n          execContext['$$'+counterName]++;\n        }\n        return execContext['$$'+counterName];\n      }",
            "var getCoordinate = function(source, zoom) {\n        zoom = zoom || 6;\n        if(source == null) {\n          return [51.505,-0.09, zoom];\n        } else {\n          return [source[0], source[1], zoom];\n        }\n      }"
        ];
        this._functions = [];
        this._functionsStr = '';
        this._initFunctions();
    }
    AjfValidationService.prototype.addFunction = function (f) {
        this._functions.push(f);
        this._initFunctions();
    };
    AjfValidationService.prototype.addFunctionHandler = function (name, fn) {
        if (AjfExpressionUtils.utils[name] === undefined) {
            AjfExpressionUtils.utils[name] = { fn: fn };
        }
    };
    AjfValidationService.prototype._initFunctions = function () {
        var functionsStr = this._functions
            .map(function (f) { return typeof f === 'string' ? f : f.toString(); })
            .join('; ');
        this._functionsStr = this._baseUtilFunctions.join('; ') + "; " + functionsStr;
        AjfExpressionUtils.UTIL_FUNCTIONS = this._functionsStr;
    };
    AjfValidationService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AjfValidationService.ctorParameters = function () { return []; };
    return AjfValidationService;
}());
export { AjfValidationService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbi1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2NvcmUvZm9ybXMvdmFsaWRhdGlvbi1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUVILE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQ3BELE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFekM7SUE4VkU7UUE1VlEsdUJBQWtCLEdBQWE7WUFDckMsb09BSzZEO1lBQzdELDBSQU9FO1lBQ0YsZ01BS29EO1lBQ3BELHNUQU9FO1lBQ0Ysc1FBS3dGO1lBQ3hGLDRLQUtFO1lBQ0YsZ05BS3NGO1lBQ3RGLG1xQkFxQkk7WUFDSixtWUFZSTtZQUNKLDR2QkFtQkk7WUFDSixvcUJBbUJJO1lBQ0YsbzFCQXdCRTtZQUNKLHVrQkFnQkk7WUFDSiwyK0JBNEJJO1lBQ0osbWpCQWVJO1lBQ0osa1JBUUk7WUFDSix5OENBc0NJO1lBQ0oscTRDQTZDSTtZQUNKLHNXQVNJO1lBQ0osNkhBR0k7WUFDSixrSUFHSTtZQUNKLDRLQUlJO1lBQ0oscVdBUUk7WUFDSixxT0FPSTtTQUNMLENBQUM7UUFFTSxlQUFVLEdBQTBCLEVBQUUsQ0FBQztRQUN2QyxrQkFBYSxHQUFXLEVBQUUsQ0FBQztRQUdqQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVELDBDQUFXLEdBQVgsVUFBWSxDQUFvQjtRQUM5QixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVELGlEQUFrQixHQUFsQixVQUFtQixJQUFZLEVBQUUsRUFBTztRQUN0QyxJQUFJLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxTQUFTLEVBQUU7WUFDaEQsa0JBQWtCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUMsRUFBRSxJQUFBLEVBQUMsQ0FBQztTQUN2QztJQUNILENBQUM7SUFFTyw2Q0FBYyxHQUF0QjtRQUNFLElBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFVO2FBQ2pDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQXhDLENBQXdDLENBQUM7YUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLGFBQWEsR0FBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFLLFlBQWMsQ0FBQztRQUM5RSxrQkFBa0IsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUN6RCxDQUFDOztnQkFuWEYsVUFBVTs7OztJQW9YWCwyQkFBQztDQUFBLEFBcFhELElBb1hDO1NBblhZLG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbnVjb29wIHNvYy4gY29vcC5cbiAqXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQWR2YW5jZWQgSlNPTiBmb3JtcyAoYWpmKS5cbiAqXG4gKiBBZHZhbmNlZCBKU09OIGZvcm1zIChhamYpIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICogbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSxcbiAqIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogQWR2YW5jZWQgSlNPTiBmb3JtcyAoYWpmKSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgQWZmZXJvXG4gKiBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIEFkdmFuY2VkIEpTT04gZm9ybXMgKGFqZikuXG4gKiBJZiBub3QsIHNlZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvLlxuICpcbiAqL1xuXG5pbXBvcnQge0FqZkV4cHJlc3Npb25VdGlsc30gZnJvbSAnQGFqZi9jb3JlL21vZGVscyc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQWpmVmFsaWRhdGlvblNlcnZpY2Uge1xuICBwcml2YXRlIF9iYXNlVXRpbEZ1bmN0aW9uczogc3RyaW5nW10gPSBbXG4gICAgYC8qKlxuICAgICAgICAqIGNvdW50IHRoZSBudW1iZXIgb2YgZGlnaXQgY29udGFpbmVkIG9uIHguXG4gICAgICAgICogQHBhcmFtICB4IHRoZSB2YWx1ZSB1c2VkIGZvciBkaWdpdCBjb3VudFxuICAgICAgICAqIEByZXR1cm4gdGhlIGNvdW50IG9mIHRoZSBkaWdpdFxuICAgICAgKi9cbiAgICB2YXIgZGlnaXRDb3VudCA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgudG9TdHJpbmcoKS5sZW5ndGg7IH1gLFxuICAgIGAvKipcbiAgICAgICAgKiBjb3VudCB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgY29udGFpbmVkIG9uIHguXG4gICAgICAgICogQHBhcmFtICB4IHRoZSB2YWx1ZSB1c2VkIGZvciBkZWNpbWFsIGNvdW50XG4gICAgICAgICogQHJldHVybiB0aGUgY291bnQgb2YgdGhlIGRlY2ltYWxcbiAgICAgICovXG4gICAgdmFyIGRlY2ltYWxDb3VudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAocGFyc2VGbG9hdCh4KS50b1N0cmluZygpLnNwbGl0KCcuJylbMV0gfHwgW10pLmxlbmd0aDtcbiAgICB9YCxcbiAgICBgLyoqXG4gICAgICAgICogY2hlY2sgaWYgeCBpcyBpbnRlZ2VyXG4gICAgICAgICogQHBhcmFtICB4IHRoZSB2YWx1ZSB1c2VkIGZvciBjaGVja1xuICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiB4IGlzIGEgbnVtYmVyXG4gICAgICAqL1xuICAgIHZhciBpc0ludCA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICEvWywuXS8udGVzdCh4KTsgfWAsXG4gICAgYC8qKlxuICAgICAgICAqIGNoZWNrIGlmIHggaXMgbm90IGVtcGl0eVxuICAgICAgICAqIEBwYXJhbSAgeCB0aGUgdmFsdWUgdXNlZCBmb3IgY2hlY2tcbiAgICAgICAgKiBAcmV0dXJuIHRydWUgaWYgeCBkZWZpbmVkIGFuZCBub3QgbnVsbCBhbmQgdGhlIG51bWJlciBvZiBkaWdpdCBpcyA+IDBcbiAgICAgICovXG4gICAgdmFyIG5vdEVtcHR5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHggIT09ICd1bmRlZmluZWQnICYmIHggIT09IG51bGwgPyB4LnRvU3RyaW5nKCkubGVuZ3RoID4gMCA6IGZhbHNlKTtcbiAgICB9YCxcbiAgICBgLyoqXG4gICAgICAgICogY2hlY2sgaWYgeCBpcyBjb250YWluZWQgb24gYXJyYXlcbiAgICAgICAgKiBAcGFyYW0gIHggdGhlIHZhbHVlIHVzZWQgZm9yIGNoZWNrXG4gICAgICAgICogQHJldHVybiB0aGUgcG9zaXRpb24gb2YgeCBvbiBhcnJheSBvciBpZiBhcnJheSA9PT0geFxuICAgICAgKi9cbiAgICB2YXIgdmFsdWVJbkNob2ljZSA9IGZ1bmN0aW9uKGFycmF5LCB4KSB7IHJldHVybiBhcnJheS5pbmRleE9mKHgpID4gLTEgfHwgYXJyYXkgPT09IHg7IH1gLFxuICAgIGB2YXIgc2Nhbkdyb3VwRmllbGQgPSBmdW5jdGlvbihyZXBzLCBhY2MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwczsgaSsrKSB7XG4gICAgICAgICAgICBhY2MgPSBjYWxsYmFjayhhY2MsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfWAsXG4gICAgYC8qKlxuICAgICAgICAqIHN1bSB0aGUgdmFsdWUgY29udGFpbmVkIG9uIGFycmF5XG4gICAgICAgICogQHBhcmFtICB4IHRoZSBhcnJheVxuICAgICAgICAqIEByZXR1cm4gdGhlIHN1bVxuICAgICAgKi9cbiAgICB2YXIgc3VtID0gZnVuY3Rpb24oYXJyYXkpIHtyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYSArIGI7IH0sIDApOyB9YCxcbiAgICBgdmFyIGRhdGVPcGVyYXRpb25zID0gZnVuY3Rpb24oZFN0cmluZywgcGVyaW9kLCBvcGVyYXRpb24sIHYpIHtcbiAgICAgICAgZm10ID0gJ21tL2RkL3l5eXknO1xuICAgICAgICB2YXIgZCA9ICh0eXBlb2YgZFN0cmluZyAhPT0gJ3VuZGVmaW5lZCcpID8gZGF0ZVV0aWxzLnBhcnNlKGRTdHJpbmcpIDogbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PSAncmVtb3ZlJykge1xuICAgICAgICAgIHYgPSAtdjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0ZU9wO1xuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBkYXRlT3AgPSBkYXRlVXRpbHMuYWRkRGF5cztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIGRhdGVPcCA9IGRhdGVVdGlscy5hZGRNb250aHM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIGRhdGVPcCA9IGRhdGVVdGlscy5hZGRZZWFycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVVdGlscy5mb3JtYXQoZGF0ZU9wKGQsIHYpLCBmbXQpO1xuICAgICAgfWAsXG4gICAgYC8qKlxuICAgICAgICAqIHJvdW5kIHRoZSBudW1cbiAgICAgICAgKiBAcGFyYW0gIG51bSB0aGUgdmFsdWUgdG8gcm91bmRcbiAgICAgICAgKiBAcGFyYW0gIGRpZ2l0cyBob3cgbWFueSBkaWdpdFxuICAgICAgICAqIEByZXR1cm4gbnVtIHJvdW5kZWRcbiAgICAgICovXG4gICAgICB2YXIgcm91bmQgPSBmdW5jdGlvbihudW0sIGRpZ2l0cykge1xuICAgICAgICBkaWdpdHMgPSBkaWdpdHMgfHwgMDtcbiAgICAgICAgdmFyIGYgPSAwO1xuICAgICAgICB0cnkgeyBmID0gcGFyc2VGbG9hdChudW0pOyB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgdmFyIG0gPSBNYXRoLnBvdygxMCwgZGlnaXRzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZiAqIG0pIC8gbTtcbiAgICAgIH1gLFxuICAgIGAvKipcbiAgICAgICAgKiBleHRyYWN0IHRoZSBwcm9wZXJ0eSBvZiB0aGUgc291cmNlIG9iamVjdCB3aXRoIHByb3BlcnR5ICE9IG51bGxcbiAgICAgICAgKiBAcGFyYW0gIHNvdXJjZSBhcnJheSBvZiBvYmplY3Qgd2ljaCBjb250YWlucyBwcm9wZXJ0eVxuICAgICAgICAqIEBwYXJhbSAgcHJvcGVydHkgdGhlIHByb3BlcnR5IG9uIHdpY2ggd2Ugd2FudCBmaWx0ZXJcbiAgICAgICAgKiBAcmV0dXJuIGFycmF5IG9mIGRhdGVzXG4gICAgICAqL1xuICAgICAgdmFyIGV4dHJhY3RBcnJheSA9IGZ1bmN0aW9uKHNvdXJjZSwgcHJvcGVydHksIHByb3BlcnR5Mikge1xuICAgICAgICBzb3VyY2UgPSAoc291cmNlIHx8IFtdKS5zbGljZSgwKTtcbiAgICAgICAgdmFyIGwgPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbCA7IGkrKykge1xuICAgICAgICAgIGlmIChzb3VyY2VbaV1bcHJvcGVydHldICE9IG51bGwgJiYgc291cmNlW2ldW3Byb3BlcnR5Ml0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzLnB1c2goc291cmNlW2ldW3Byb3BlcnR5XSArIHNvdXJjZVtpXVtwcm9wZXJ0eTJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc291cmNlW2ldW3Byb3BlcnR5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXMucHVzaChzb3VyY2VbaV1bcHJvcGVydHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1gLFxuICAgIGAvKipcbiAgICAgICAgKiBleHRyYWN0IHRoZSBwcm9wZXJ0eSBvZiB0aGUgc291cmNlIG9iamVjdCB3aXRoIHByb3BlcnR5ICE9IG51bGxcbiAgICAgICAgKiBAcGFyYW0gIHNvdXJjZSBhcnJheSBvZiBvYmplY3Qgd2ljaCBjb250YWlucyBwcm9wZXJ0eVxuICAgICAgICAqIEBwYXJhbSAgcHJvcGVydHVlcyBzdHJpbmcgYXJyYXkgdGhlIHByb3BlcnRpZXMgdG8gc3VtXG4gICAgICAgICogQHJldHVybiB0aGUgc3VtXG4gICAgICAqL1xuICAgICAgdmFyIGV4dHJhY3RTdW0gPSBmdW5jdGlvbihzb3VyY2UsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHByb3BlcnRpZXMgPSAocHJvcGVydGllcyB8fCBbXSkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBsID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsIDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gZXh0cmFjdEFycmF5KHNvdXJjZSwgcHJvcGVydGllc1tpXSk7XG4gICAgICAgICAgdmFyIGxlbmcgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbmc7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGFycmF5W2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgfWAsXG4gICAgICBgLyoqXG4gICAgICAgICogZXh0cmFjdCB0aGUgYXJyYXkgb2Ygc3VtIGZvciBlYWNoIHdlZWsgIT0gbnVsbFxuICAgICAgICAqIEBwYXJhbSAgc291cmNlIGFycmF5IG9mIG9iamVjdCB3aWNoIGNvbnRhaW5zIHByb3BlcnR5XG4gICAgICAgICogQHBhcmFtICBwcm9wZXJ0dWVzIHN0cmluZyBhcnJheSB0aGUgcHJvcGVydGllcyB0byBzdW1cbiAgICAgICAgKiBAcmV0dXJuIHRoZSBzdW1cbiAgICAgICovXG4gICAgICB2YXIgZXh0cmFjdEFycmF5U3VtID0gZnVuY3Rpb24oc291cmNlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICAgICAgcHJvcGVydGllcyA9IChwcm9wZXJ0aWVzIHx8IFtdKS5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wSSA9IDA7IHByb3BJIDwgcHJvcGVydGllcy5sZW5ndGggOyBwcm9wSSsrKSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gZXh0cmFjdEFycmF5KHNvdXJjZSwgcHJvcGVydGllc1twcm9wSV0pO1xuICAgICAgICAgIGFycmF5cy5wdXNoKGFycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgd2Vla0kgPSAwOyB3ZWVrSSA8IGFycmF5Lmxlbmd0aDsgd2Vla0kgKysgKSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcEkgPSAwOyBwcm9wSSA8IHByb3BlcnRpZXMubGVuZ3RoIDsgcHJvcEkrKykge1xuICAgICAgICAgICAgc3VtID0gc3VtICsgYXJyYXlzW3Byb3BJXVt3ZWVrSV1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goc3VtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfWAsXG4gICAgYC8qKlxuICAgICAgICAqIGRyYXcgYSB0aHJlc2hvbGQgbGluZSBvbiBjaGFydCByZWxhdGVkIHRvIHRoZSBwcm9wZXJ0eVxuICAgICAgICAqIEBwYXJhbSAgc291cmNlIGFycmF5IG9mIG9iamVjdCB3aWNoIGNvbnRhaW5zIHByb3BlcnR5XG4gICAgICAgICogQHBhcmFtICBwcm9wZXJ0eSB0aGUgcHJvcGVydHkgb24gd2ljaCB3ZSB3YW50IGZpbHRlclxuICAgICAgICAqIEByZXR1cm4gYXJyYXkgb2YgZGF0ZXNcbiAgICAgICovXG4gICAgICB2YXIgZHJhd1RocmVzaG9sZCA9IGZ1bmN0aW9uKHNvdXJjZSwgcHJvcGVydHksIHRocmVzaG9sZCkge1xuICAgICAgICBzb3VyY2UgPSAoc291cmNlIHx8IFtdKS5zbGljZSgwKTtcbiAgICAgICAgdmFyIGwgPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbCA7IGkrKykge1xuICAgICAgICAgIGlmIChzb3VyY2VbaV1bcHJvcGVydHldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHRocmVzaG9sZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9YCxcbiAgICBgLyoqXG4gICAgICAgICogZXh0cmFjdCB0aGUgZGF0ZXMgb2YgdGhlIHNvdXJjZSBvYmplY3Qgd2l0aCBwcm9wZXJ0eSAhPSBudWxsXG4gICAgICAgICogQHBhcmFtICBzb3VyY2UgYXJyYXkgb2Ygb2JqZWN0IHdpY2ggY29udGFpbnMgcHJvcGVydHkgYW5kIGRhdGVfc3RhcnRcbiAgICAgICAgKiBAcGFyYW0gIHByb3BlcnR5IHRoZSBwcm9wZXJ0eSBvbiB3aWNoIHdlIHdhbnQgdG8gY2FsY3VsYXRlIGRhdGVzXG4gICAgICAgICogQHBhcmFtICBmb3JtYXQgdGhlIGZvcm1hdCBvZiB0aGUgZGF0ZVxuICAgICAgICAqIEByZXR1cm4gYXJyYXkgb2YgZGF0ZXNcbiAgICAgICovXG4gICAgICB2YXIgZXh0cmFjdERhdGVzID0gZnVuY3Rpb24oc291cmNlLCBwcm9wZXJ0eSwgZm9ybWF0KSB7XG4gICAgICAgIHNvdXJjZSA9IChzb3VyY2UgfHwgW10pLnNsaWNlKDApO1xuICAgICAgICB2YXIgbCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIHByZWZpeCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwgOyBpKyspIHtcbiAgICAgICAgICBpZiAoc291cmNlW2ldW3Byb3BlcnR5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2goZm9ybWF0KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiV1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIk1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2gocHJlZml4ICsgZm9ybWF0RGF0ZShzb3VyY2VbaV1bXCJkYXRlX3N0YXJ0XCJdLCBmb3JtYXQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1gLFxuICAgIGAvKipcbiAgICAgICAgKiBleHRyYWN0IHRoZSBsYXN0IHByb3BlcnR5IGNvbnRhaW5zIGluIHNvdXJjZSAhPSBudWxsXG4gICAgICAgICogQHBhcmFtICBzb3VyY2UgYXJyYXkgb2Ygb2JqZWN0IHdpY2ggY29udGFpbnMgcHJvcGVydHkgYW5kIGRhdGVfc3RhcnRcbiAgICAgICAgKiBAcGFyYW0gIHByb3BlcnR5IHRoZSBwcm9wZXJ0eSB0byBmaW5kXG4gICAgICAgICogQHJldHVybiB0aGUgbGFzdCBwcm9wZXJ0eSAhPSBudWxsXG4gICAgICAqL1xuICAgICAgdmFyIGxhc3RQcm9wZXJ0eSA9IGZ1bmN0aW9uKHNvdXJjZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc291cmNlID0gKHNvdXJjZSB8fCBbXSkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBsID0gc291cmNlLmxlbmd0aCAtMTtcblxuICAgICAgICB3aGlsZSAobCA+PSAwICYmIHNvdXJjZVtsXVtwcm9wZXJ0eV0gPT0gbnVsbCkge1xuICAgICAgICAgIGwtLTtcbiAgICAgICAgICBpZiAobCA8IDApIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsID49IDAgPyBzb3VyY2VbbF1bcHJvcGVydHldIDogMDtcbiAgICAgIH1gLFxuICAgIGB2YXIgc3VtTGFzdFByb3BlcnRpZXMgPSBmdW5jdGlvbihzb3VyY2UsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgc291cmNlID0gKHNvdXJjZSB8fCBbXSkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdW0gKz0gbGFzdFByb3BlcnR5KHNvdXJjZSwgcHJvcGVydGllc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgfWAsXG4gICAgYC8qKlxuICAgICAgICAqIGNvbXB1dGUgdGhlIHRyZW5kIG9mIHRoZSBwcm9wZXJ0eSBjb250YWluZWQgb24gdGhlIHNvdXJjZS5cbiAgICAgICAgKiBAcGFyYW0gIHNvdXJjZSBhcnJheSBvZiBvYmplY3Qgd2ljaCBjb250YWlucyBwcm9wZXJ0eVxuICAgICAgICAqIEBwYXJhbSAgcHJvcGVydHkgdGhlIHByb3BlcnR5IG9uIHdpY2ggd2Ugd2FudCB0byBjYWxjdWxhdGUgdGhlIHRyZW5kXG4gICAgICAgICogQHJldHVybiBhbiBodG1sIGljb24gdGhhdCBpZGVudGlmaWVzIHRoZSB0cmVuZFxuICAgICAgKi9cbiAgICAgIHZhciBjYWxjdWxhdGVUcmVuZFByb3BlcnR5ID0gZnVuY3Rpb24oc291cmNlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzb3VyY2UgPSAoc291cmNlIHx8IFtdKS5zbGljZSgwKTtcbiAgICAgICAgdmFyIGxhc3QgPSBzb3VyY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZVtsYXN0XVtwcm9wZXJ0eV0gPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0LS07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RMYXN0ID0gbGFzdCAtIDE7XG4gICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICBsYXN0TGFzdCA9IGxhc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKHNvdXJjZVtsYXN0TGFzdF1bcHJvcGVydHldID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0TGFzdCA9PSAwKSB7XG4gICAgICAgICAgICAgIGxhc3RMYXN0ID0gbGFzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TGFzdC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0UHJvcGVydHkgPSBzb3VyY2VbbGFzdF0/KHNvdXJjZVtsYXN0XVtwcm9wZXJ0eV0gfHwgMCk6IDA7XG4gICAgICAgIHZhciBsYXN0TGFzdFByb3BlcnR5ID0gc291cmNlW2xhc3RMYXN0XT8oc291cmNlW2xhc3RMYXN0XVtwcm9wZXJ0eV0gfHwgMCk6IDA7XG5cbiAgICAgICAgaWYgKGxhc3RQcm9wZXJ0eSA9PSBsYXN0TGFzdFByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuICc8cD48aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCIgc3R5bGU9XCJjb2xvcjpibHVlXCI+dHJlbmRpbmdfZmxhdDwvaT48L3A+JztcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcGVydHkgPiBsYXN0TGFzdFByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuICc8cD48aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCIgc3R5bGU9XCJjb2xvcjpncmVlblwiPnRyZW5kaW5nX3VwPC9pPjwvcD4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnPHA+PGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiIHN0eWxlPVwiY29sb3I6cmVkXCI+dHJlbmRpbmdfZG93bjwvaT48L3A+JztcbiAgICAgICAgfVxuICAgICAgfWAsXG4gICAgYC8qKlxuICAgICAgICAqIGNvbXB1dGUgdGhlIGF2ZXJhZ2UgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGNvbnRhaW5lZCBvbiB0aGUgc291cmNlLlxuICAgICAgICAqIEBwYXJhbSAgc291cmNlIGFycmF5IG9mIG9iamVjdCB3aWNoIGNvbnRhaW5zIHByb3BlcnR5XG4gICAgICAgICogQHBhcmFtICBwcm9wZXJ0eSB0aGUgcHJvcGVydHkgb24gd2ljaCB3ZSB3YW50IHRvIGNhbGN1bGF0ZSB0aGUgYXZlcmFnZVxuICAgICAgICAqIEBwYXJhbSAgcmFuZ2UgdGhlIHJhbmdlIG9uIHdpY2ggd2Ugd2FudCB0byBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2VcbiAgICAgICAgKiBAcGFyYW0gIGNvZWZmaWNlbnQgdGhlIGNvZWZmaWNlbnQgdXNlZCBmb3IgY2FsY3VsYXRlIHRoZSB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgIGlmIGNvZWZmaWNlbnQgaXMgMCBtZWFuIHJldHVybiB0aGUgY291bnQgb2YgcHJvcGVydHkgPiAwXG4gICAgICAgICogQHJldHVybiB0aGUgYXZlcmFnZSB2YWx1ZSB8fCB0aGUgY291bnQgb2YgcHJvcGVydHkgPiAwXG4gICAgICAqL1xuICAgICAgdmFyIGNhbGN1bGF0ZUF2Z1Byb3BlcnR5ID0gZnVuY3Rpb24oc291cmNlLCBwcm9wZXJ0eSwgcmFuZ2UsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IChzb3VyY2UgfHwgW10pLnNsaWNlKDApO1xuXG4gICAgICAgIHNvdXJjZS5wb3AoKTtcblxuICAgICAgICBjb2VmZmljaWVudCA9IGNvZWZmaWNpZW50IHx8IDE7XG4gICAgICAgIHJhbmdlID0gcmFuZ2UgfHwgMTI7XG5cbiAgICAgICAgdmFyIGwgPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzID0gMDtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgbm9aZXJvID0gMDtcblxuICAgICAgICBpZihsIDwgcmFuZ2UpIHtcbiAgICAgICAgICByYW5nZSA9IGw7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmFuZ2UgIT0gMCkge1xuICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICBpZiAoc291cmNlW2wgLSAxXVtwcm9wZXJ0eV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzICs9IHNvdXJjZVtsIC0gMV1bcHJvcGVydHldO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlW2wgLSAxXVtwcm9wZXJ0eV0gPiAwKSB7XG4gICAgICAgICAgICAgIG5vWmVybysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsLS07XG4gICAgICAgICAgcmFuZ2UtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5vWmVybztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGhyZXNob2xkID0gKHJlcy9jb3VudGVyKSpjb2VmZmljaWVudCB8fCAwO1xuICAgICAgICAgIHJldHVybiB0aHJlc2hvbGQ7XG4gICAgICAgIH1cbiAgICAgIH1gLFxuICAgIGB2YXIgYWxlcnQgPSBmdW5jdGlvbihzb3VyY2UsIHByb3BlcnR5LCB0aHJlc2hvbGQsIGZtdCkge1xuICAgICAgICBzb3VyY2UgPSAoc291cmNlIHx8IFtdKS5zbGljZSgwKTtcbiAgICAgICAgdmFyIGwgPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICAgIGlmICggbGFzdFByb3BlcnR5KHNvdXJjZSwgcHJvcGVydHkpICA+IHRocmVzaG9sZCApIHtcbiAgICAgICAgICByZXR1cm4gJzxwPjxpIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIiBzdHlsZT1cImNvbG9yOnJlZFwiPndhcm5pbmc8L2k+PC9wPic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnPHA+PC9wPic7XG4gICAgICAgICAgfVxuICAgICAgfWAsXG4gICAgYHZhciBmb3JtYXROdW1iZXIgPSBmdW5jdGlvbihudW0sIGZtdCkge1xuICAgICAgICBmbXQgPSBmbXQgfHwgJzAsMFsuXTAnO1xuICAgICAgICByZXR1cm4gbnVtZXJhbChudW0pLmZvcm1hdChmbXQpO1xuICAgICAgfWAsXG4gICAgYHZhciBmb3JtYXREYXRlID0gZnVuY3Rpb24oZGF0ZSwgZm10KSB7XG4gICAgICAgIGZtdCA9IGZtdCB8fCAnbW0tZGQteXl5eSc7XG4gICAgICAgIHJldHVybiBkYXRlVXRpbHMuZm9ybWF0KGRhdGUsIGZtdCk7XG4gICAgICB9YCxcbiAgICBgdmFyIGlzb01vbnRoID0gZnVuY3Rpb24oZGF0ZSwgZm10KSB7XG4gICAgICAgIGZtdCA9IGZtdCB8fCAnbW0nO1xuICAgICAgICB2YXIgZHUgPSBkYXRlVXRpbHM7XG4gICAgICAgIHJldHVybiBkdS5mb3JtYXQoZHUuYWRkRGF5cyhkdS5zdGFydE9mTW9udGgoZGF0ZSksIDQpLGZtdClcbiAgICAgIH1gLFxuICAgIGB2YXIgbmV4dENvdW50ZXJWYWx1ZSA9IGZ1bmN0aW9uKGNvdW50ZXJOYW1lLCBmaXJzdFZhbHVlKSB7XG4gICAgICAgIGZpcnN0VmFsdWUgPSBmaXJzdFZhbHVlICE9IG51bGwgPyBmaXJzdFZhbHVlIDogMDtcbiAgICAgICAgaWYgKGV4ZWNDb250ZXh0WyckJCcrY291bnRlck5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBleGVjQ29udGV4dFsnJCQnK2NvdW50ZXJOYW1lXSA9IGZpcnN0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY0NvbnRleHRbJyQkJytjb3VudGVyTmFtZV0rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhlY0NvbnRleHRbJyQkJytjb3VudGVyTmFtZV07XG4gICAgICB9YCxcbiAgICBgdmFyIGdldENvb3JkaW5hdGUgPSBmdW5jdGlvbihzb3VyY2UsIHpvb20pIHtcbiAgICAgICAgem9vbSA9IHpvb20gfHwgNjtcbiAgICAgICAgaWYoc291cmNlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gWzUxLjUwNSwtMC4wOSwgem9vbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtzb3VyY2VbMF0sIHNvdXJjZVsxXSwgem9vbV07XG4gICAgICAgIH1cbiAgICAgIH1gXG4gIF07XG5cbiAgcHJpdmF0ZSBfZnVuY3Rpb25zOiAoRnVuY3Rpb24gfCBzdHJpbmcpW10gPSBbXTtcbiAgcHJpdmF0ZSBfZnVuY3Rpb25zU3RyOiBzdHJpbmcgPSAnJztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0RnVuY3Rpb25zKCk7XG4gIH1cblxuICBhZGRGdW5jdGlvbihmOiBGdW5jdGlvbiB8IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2Z1bmN0aW9ucy5wdXNoKGYpO1xuICAgIHRoaXMuX2luaXRGdW5jdGlvbnMoKTtcbiAgfVxuXG4gIGFkZEZ1bmN0aW9uSGFuZGxlcihuYW1lOiBzdHJpbmcsIGZuOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoQWpmRXhwcmVzc2lvblV0aWxzLnV0aWxzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIEFqZkV4cHJlc3Npb25VdGlscy51dGlsc1tuYW1lXSA9IHtmbn07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdEZ1bmN0aW9ucygpOiB2b2lkIHtcbiAgICBjb25zdCBmdW5jdGlvbnNTdHIgPSB0aGlzLl9mdW5jdGlvbnNcbiAgICAgIC5tYXAoZiA9PiB0eXBlb2YgZiA9PT0gJ3N0cmluZycgPyBmIDogZi50b1N0cmluZygpKVxuICAgICAgLmpvaW4oJzsgJyk7XG4gICAgdGhpcy5fZnVuY3Rpb25zU3RyID0gYCR7dGhpcy5fYmFzZVV0aWxGdW5jdGlvbnMuam9pbignOyAnKX07ICR7ZnVuY3Rpb25zU3RyfWA7XG4gICAgQWpmRXhwcmVzc2lvblV0aWxzLlVUSUxfRlVOQ1RJT05TID0gdGhpcy5fZnVuY3Rpb25zU3RyO1xuICB9XG59XG4iXX0=