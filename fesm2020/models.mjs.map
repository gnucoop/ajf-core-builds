{"version":3,"file":"models.mjs","sources":["../../../../../../src/core/models/context.ts","../../../../../../src/core/models/error.ts","../../../../../../src/core/models/interface/condition.ts","../../../../../../src/core/models/interface/formula.ts","../../../../../../src/core/models/interface/validation-function.ts","../../../../../../src/core/models/utils/create-condition.ts","../../../../../../src/core/models/serializers/condition-serializer.ts","../../../../../../src/core/models/utils/create-formula.ts","../../../../../../src/core/models/serializers/formula-serializer.ts","../../../../../../src/core/models/utils/always-condition.ts","../../../../../../src/core/models/utils/expression-utils.ts","../../../../../../src/core/models/utils/get-context-string.ts","../../../../../../src/core/models/utils/never-condition.ts","../../../../../../src/core/models/utils/normalize-expression.ts","../../../../../../src/core/models/utils/validate-expression.ts","../../../../../../src/core/models/public-api.ts","../../../../../../src/core/models/index.ts","../../../../../../src/core/models/models_public_index.ts"],"sourcesContent":["/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nexport type AjfContext = import('@ajf/core/common').AjfContext;\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nexport class AjfError extends Error {\n  override stack: string;\n  override get name(): string {\n    return 'AjfError';\n  }\n  override get message(): string {\n    return this._message;\n  }\n  // this private string is the error message\n  private _message: string;\n  /**\n   * this constructor will init the message error\n   */\n  constructor(message?: string) {\n    super(message);\n\n    // Set the prototype explicitly. Workaround needed in TS >= 2.1 when extending built-ins\n    // See: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md\n    Object.setPrototypeOf(this, AjfError.prototype);\n\n    this._message = message || '';\n  }\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\n/**\n * A string expression representing a condition to be evaluated\n * (eg. for a visibility or validation check)\n */\nexport interface AjfCondition {\n  /**\n   * The string expression to be evaluated\n   */\n  condition: string;\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nexport interface AjfFormula {\n  formula: string;\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nexport type AjfValidationFn = {\n  fn: any;\n};\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfCondition} from '../interface/condition';\n\n/**\n * It Creates an AjfCondition by conditio.\n * If condition.condition is not defined will be assigned ''.\n */\nexport function createCondition(condition: Partial<AjfCondition> = {}): AjfCondition {\n  return {condition: condition.condition || ''};\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfCondition} from '../interface/condition';\nimport {createCondition} from '../utils/create-condition';\n\nexport class AjfConditionSerializer {\n  static fromJson(json: Partial<AjfCondition>): AjfCondition {\n    return createCondition(json);\n  }\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfFormula} from '../interface/formula';\n\n/**\n * It Creates an AjfFormula.\n * If formula.formula is not defined will be assigned ''.\n */\nexport function createFormula(formula: Partial<AjfFormula> = {}): AjfFormula {\n  return {formula: formula.formula || ''};\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfFormula} from '../interface/formula';\nimport {createFormula} from '../utils/create-formula';\n\nexport class AjfFormulaSerializer {\n  static fromJson(json: Partial<AjfFormula>): AjfFormula {\n    return createFormula(json);\n  }\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfCondition} from '../interface/condition';\nimport {createCondition} from './create-condition';\n/**\n * It creates a true AjfCondidion.\n */\nexport function alwaysCondition(): AjfCondition {\n  return createCondition({condition: 'true'});\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfContext} from '@ajf/core/common';\nimport * as dateFns from 'date-fns';\nimport {parseScript} from 'meriyah';\nimport * as numbroMod from 'numbro';\nimport {AjfTableCell} from '@ajf/core/table';\n\nimport {AjfValidationFn} from '../interface/validation-function';\n\nlet execContext: any = {};\n\nconst numbro = numbroMod.default || numbroMod;\nexport interface Form {\n  [key: string]: string | number | null;\n}\nexport interface Instances {\n  [instance: string]: Form[];\n}\nexport interface MainForm {\n  [key: string]: string | number | null | Instances | undefined | null;\n  reps?: Instances;\n}\n\nconst MAX_REPS = 30;\n\nexport const getCodeIdentifiers = (\n  source: string,\n  includeDollarValue: boolean = false,\n): string[] => {\n  const identifiers = [] as string[];\n  try {\n    parseScript(source.toString(), {\n      onToken: (token, start, end) => {\n        if (token == 'Identifier') {\n          const identifier = source.toString().substring(start, end);\n          if (includeDollarValue || identifier !== '$value') {\n            identifiers.push(identifier);\n          }\n        }\n      },\n    });\n  } catch (e) {\n    console.log(source);\n    console.log(e);\n  }\n  return identifiers;\n};\n\nexport const dateUtils = {\n  addDays: dateFns.addDays,\n  addMonths: dateFns.addMonths,\n  addYears: dateFns.addYears,\n  endOfISOWeek: dateFns.endOfISOWeek,\n  format: dateFns.format,\n  getDay: dateFns.getDay,\n  parse: dateFns.parseISO,\n  startOfMonth: dateFns.startOfMonth,\n  startOfISOWeek: dateFns.startOfISOWeek,\n  isBefore: dateFns.isBefore,\n};\n\nexport class AjfExpressionUtils {\n  // TODO what is it for\n  static UTIL_FUNCTIONS = '';\n  /**\n   * It is a key-value dictionary, that mapping all Ajf validation functions.\n   */\n  static utils: {[name: string]: AjfValidationFn} = {\n    digitCount: {fn: digitCount},\n    decimalCount: {fn: decimalCount},\n    isInt: {fn: isInt},\n    notEmpty: {fn: notEmpty},\n    valueInChoice: {fn: valueInChoice},\n    scanGroupField: {fn: scanGroupField},\n    sum: {fn: sum},\n    dateOperations: {fn: dateOperations},\n    round: {fn: round},\n    extractArray: {fn: extractArray},\n    extractSum: {fn: extractSum},\n    extractArraySum: {fn: extractArraySum},\n    drawThreshold: {fn: drawThreshold},\n    extractDates: {fn: extractDates},\n    lastProperty: {fn: lastProperty},\n    sumLastProperties: {fn: sumLastProperties},\n    calculateTrendProperty: {fn: calculateTrendProperty},\n    calculateTrendByProperties: {fn: calculateTrendByProperties},\n    calculateAvgProperty: {fn: calculateAvgProperty},\n    calculateAvgPropertyArray: {fn: calculateAvgPropertyArray},\n    alert: {fn: alert},\n    formatNumber: {fn: formatNumber},\n    formatDate: {fn: formatDate},\n    isoMonth: {fn: isoMonth},\n    getCoordinate: {fn: getCoordinate},\n    Math: {fn: Math},\n    parseInt: {fn: parseInt},\n    parseFloat: {fn: parseFloat},\n    parseDate: {fn: dateUtils.parse},\n    Date: {fn: Date},\n    plainArray: {fn: plainArray},\n    COUNT_FORMS: {fn: COUNT_FORMS},\n    COUNT_FORMS_UNIQUE: {fn: COUNT_FORMS_UNIQUE},\n    COUNT_REPS: {fn: COUNT_REPS},\n    SUM: {fn: SUM},\n    MEAN: {fn: MEAN},\n    PERCENT: {fn: PERCENT},\n    LAST: {fn: LAST},\n    MAX: {fn: MAX},\n    MEDIAN: {fn: MEDIAN},\n    MODE: {fn: MODE},\n    ALL_VALUES_OF: {fn: ALL_VALUES_OF},\n    REPEAT: {fn: REPEAT},\n    EVALUATE: {fn: EVALUATE},\n    buildDataset: {fn: buildDataset},\n    FILTER_BY: {fn: FILTER_BY},\n    IS_BEFORE: {fn: IS_BEFORE},\n    IS_AFTER: {fn: IS_AFTER},\n    IS_WITHIN_INTERVAL: {fn: IS_WITHIN_INTERVAL},\n    APPLY: {fn: APPLY},\n    TODAY: {fn: TODAY},\n    GET_AGE: {fn: GET_AGE},\n    BUILD_DATASET: {fn: BUILD_DATASET},\n    JOIN_FORMS: {fn: JOIN_FORMS},\n    LEN: {fn: LEN},\n    JOIN_REPEATING_SLIDES: {fn: JOIN_REPEATING_SLIDES},\n    FROM_REPS: {fn: FROM_REPS},\n    ISIN: {fn: ISIN},\n    OP: {fn: OP},\n    GET_LABELS: {fn: GET_LABELS},\n    ROUND: {fn: ROUND},\n    CONSOLE_LOG: {fn: CONSOLE_LOG},\n  };\n}\n\n/**\n * UTILITY FUNCION\n * This function provide a deep copy builder of array of main forms.\n * That's a custom function related to mainforms that can be able to increase copy performance.\n *\n * @param {MainForm[]} forms\n * @return {*}  {MainForm[]}\n */\nfunction cloneMainForms(forms: MainForm[]): MainForm[] {\n  let res: MainForm[] = [];\n  forms.forEach(form => {\n    let reps: Instances = {};\n    if (form == null) {\n      res.push(null as unknown as MainForm);\n    } else {\n      if (form.reps != null) {\n        Object.keys(form.reps).forEach(key => {\n          reps[key] = form.reps![key].slice(0);\n        });\n      }\n      const f = {...form, reps};\n      res.push(f);\n    }\n  });\n  return res;\n}\nexport function evaluateExpression(\n  expression: string,\n  context?: AjfContext,\n  forceFormula?: string,\n): any {\n  let formula = forceFormula || expression || '';\n  if (formula === '') {\n    return '';\n  }\n  if (formula === 'true') {\n    return true;\n  }\n  if (formula === 'false') {\n    return false;\n  }\n  if (context != null && context[formula] !== undefined) {\n    return context[formula];\n  }\n  if (/^\"[^\"]*\"$/.test(formula)) {\n    return formula.replace(/^\"+|\"+$/g, '');\n  }\n  const identifiers = getCodeIdentifiers(formula, true);\n  const ctx: any[] = [];\n  identifiers.forEach((key: string) => {\n    let val: any = null;\n    if (context != null && context[key] !== undefined) {\n      val = context[key];\n    } else if (AjfExpressionUtils.utils[key] !== undefined) {\n      const util = AjfExpressionUtils.utils[key];\n      val = util.fn;\n    }\n    ctx.push(val);\n  });\n  identifiers.push('execContext');\n  ctx.push(execContext);\n\n  try {\n    let f = new Function(...identifiers, `return ${formula}`);\n    const res = f(...ctx);\n    f = <any>null;\n    return res;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * It returns the count of digit inside x.\n */\nexport function digitCount(x: number): number {\n  if (isNaN(x) || typeof x !== 'number') {\n    return 0;\n  }\n  if (!isFinite(x)) {\n    return Infinity;\n  }\n  return x.toString().replace(/[^0-9]/g, '').length;\n}\n/**\n * It is count the count of decimal digit inside s.\n */\nexport function decimalCount(x: string | number): number {\n  if (typeof x === 'string') {\n    x = parseFloat(x);\n  }\n  if (typeof x !== 'number' || isNaN(x)) {\n    return 0;\n  }\n  const parts = x.toString().split('.');\n  return parts.length > 1 ? parts[1].length : 0;\n}\n/**\n * It is true if x is an integer.\n */\nexport function isInt(x: string | number): boolean {\n  if (typeof x === 'string') {\n    return /^-?\\d+$/.test(x);\n  }\n  if (typeof x === 'number') {\n    return Math.round(x) === x;\n  }\n  return false;\n}\n/**\n * It is true if x is not empty.\n */\nexport function notEmpty(x: any): boolean {\n  return typeof x !== 'undefined' && x !== null ? x.toString().length > 0 : false;\n}\n/**\n * It is true if array contains x or array is equal to x.\n */\nexport function valueInChoice(array: any[], x: any): boolean {\n  return (array || []).indexOf(x) > -1 || array === x;\n}\n/**\n * It applies callback for reps times and accumulate the result in acc.\n */\nexport function scanGroupField(reps: number, acc: any, callback: any): any {\n  for (let i = 0; i < reps; i++) {\n    acc = callback(acc, i);\n  }\n  return acc;\n}\n/**\n * It returns the sum of the array values.\n */\nexport function sum(array: any[]): any {\n  return array.reduce((a, b) => a + b, 0);\n}\n/**\n * It applies add/remove(operation) v (day/month/year)period to dstring and return new format date.\n */\n// TODO check if deprecated instead refacotoring parameter type\n// TODO (dString: string|null, period:'day'|'month'|'year',\n// TODO operation: 'add/remove' = 'add', v:number)\nexport function dateOperations(dString: string, period: string, operation: string, v: any): string {\n  const fmt = 'mm/dd/yyyy';\n  let d = typeof dString !== 'undefined' ? dateUtils.parse(dString) : new Date();\n  if (operation == 'remove') {\n    v = -v;\n  }\n  let dateOp;\n  switch (period) {\n    case 'day':\n      dateOp = dateUtils.addDays;\n      break;\n    case 'month':\n      dateOp = dateUtils.addMonths;\n      break;\n    case 'year':\n      dateOp = dateUtils.addYears;\n      break;\n    default:\n      return '';\n  }\n  return dateUtils.format(dateOp(d, v), fmt);\n}\n/**\n * It rounds the num with the value of digits\n */\nexport function round(num: number | string, digits?: number): number {\n  digits = digits || 0;\n  let f;\n  if (typeof num !== 'number') {\n    try {\n      f = parseFloat(num);\n    } catch (e) {}\n  } else {\n    f = num;\n  }\n  if (f == null || isNaN(f)) {\n    f = 0;\n  }\n  const m = Math.pow(10, digits);\n  return Math.round(f * m) / m;\n}\n/**\n * It extracts property from source.\n * for every element of source if property and property2 are defined return the sum\n * else if only property is defined return him.\n */\nexport function extractArray(source: any[], property: string, property2?: string): any[] {\n  source = (source || []).slice(0);\n  const l = source.length;\n  const res: any[] = [];\n  for (let i = 0; i < l; i++) {\n    if (source[i][property] != null && property2 != null && source[i][property2] != null) {\n      res.push(Number(source[i][property]) + Number(source[i][property2]));\n    } else if (source[i][property] != null) {\n      res.push(source[i][property]);\n    }\n  }\n  return res;\n}\n/**\n * It returns the sum of all defined properties of each element of source.\n */\nexport function extractSum(source: any[], properties: string[]): number {\n  let sumVal = 0;\n  properties = (properties || []).slice(0);\n  const l = properties.length;\n\n  for (let i = 0; i < l; i++) {\n    const array = extractArray(source, properties[i]);\n    const leng = array.length;\n    for (let j = 0; j < leng; j++) {\n      if (!isNaN(Number(array[j]))) {\n        sumVal += Number(array[j]);\n      }\n    }\n  }\n  return sumVal;\n}\n/**\n * It returns a number array that contains the sum of properties value inside the source.\n * extractArraySum([{a: 5}, {b: 1}, {a: 5, b: 1}], ['a', 'b']); =&gt; [6,6]\n */\nexport function extractArraySum(source: any[], properties: string[]): any[] {\n  const arrays: any[] = [];\n  properties = (properties || []).slice(0);\n\n  for (let i = 0; i < properties.length; i++) {\n    const array = extractArray(source, properties[i]);\n    arrays.push(array);\n  }\n\n  const res: any[] = [];\n  if (arrays.length > 0) {\n    for (let weekI = 0; weekI < arrays[0].length; weekI++) {\n      let sumVal = 0;\n      for (let propI = 0; propI < properties.length; propI++) {\n        sumVal = sumVal + Number(arrays[propI][weekI]);\n      }\n      res.push(sumVal);\n    }\n  }\n  return res;\n}\n/**\n * Draw a threshold line on chart related to the property.\n */\nexport function drawThreshold(source: any[], property: string, threshold: any[]): any[] {\n  source = (source || []).slice(0);\n  threshold = threshold || [0];\n  if (!(threshold instanceof Array)) {\n    threshold = [threshold];\n  }\n  const l = source.length;\n  const res: any[] = [];\n  let count = 0;\n  for (let i = 0; i < l; i++) {\n    if (source[i][property] != null) {\n      if (threshold.length > count) {\n        res.push(threshold[count]);\n      } else {\n        res.push(threshold[0]);\n      }\n      count++;\n    }\n  }\n  return res;\n}\n/**\n * Extract the dates of the source object with property != null\n */\nexport function extractDates(source: any[], property: string, fmt: string): string[] {\n  source = (source || []).slice(0);\n  const l = source.length;\n  const res: any = [];\n  let prefix = '';\n  for (let i = 0; i < l; i++) {\n    if (source[i][property] != null) {\n      switch (fmt) {\n        case 'WW':\n        case 'ww':\n          prefix = 'W';\n          res.push(prefix + formatDate(source[i]['date_start'], fmt));\n          break;\n        case 'MM':\n        case 'mm':\n          prefix = 'M';\n          res.push(prefix + isoMonth(source[i]['date_start'], fmt));\n          break;\n        default:\n          prefix = '';\n          res.push(prefix + formatDate(source[i]['date_start'], fmt));\n      }\n    }\n  }\n  return res;\n}\n/**\n * Extract the last property contains in source != null\n */\nexport function lastProperty(source: any, property: string): any {\n  source = (source || []).slice(0);\n  let l = source.length - 1;\n\n  while (l >= 0 && source[l][property] == null) {\n    l--;\n    if (l < 0) {\n      return '';\n    }\n  }\n  return l >= 0 ? source[l][property] : '';\n}\n/**\n * It sum the LAst properties of source.\n */\nexport function sumLastProperties(source: any[], properties: string[]): number {\n  source = (source || []).slice(0);\n  let sumVal = 0;\n  let val = 0;\n  for (let i = 0; i < properties.length; i++) {\n    val = Number(lastProperty(source, properties[i]));\n    if (!isNaN(val)) {\n      sumVal += val;\n    }\n  }\n  return sumVal;\n}\n/**\n * Compute the trend of the property contained on the source.\n */\nexport function calculateTrendProperty(source: any[], property: string): string {\n  source = (source || []).slice(0);\n  let last = source.length - 1;\n  while (source[last][property] == null) {\n    if (last == 0) {\n      break;\n    }\n    last--;\n  }\n  let lastLast = last - 1;\n  if (last == 0) {\n    lastLast = last;\n  } else {\n    while (source[lastLast][property] == null) {\n      if (lastLast == 0) {\n        lastLast = last;\n        break;\n      }\n      lastLast--;\n    }\n  }\n\n  const lastProp = source[last] ? source[last][property] || 0 : 0;\n  const lastLastProp = source[lastLast] ? source[lastLast][property] || 0 : 0;\n\n  if (lastProp == lastLastProp) {\n    return '<p><i class=\"material-icons\" style=\"color:blue\">trending_flat</i></p>';\n  } else if (lastProp > lastLastProp) {\n    return '<p><i class=\"material-icons\" style=\"color:green\">trending_up</i></p>';\n  } else {\n    return '<p><i class=\"material-icons\" style=\"color:red\">trending_down</i></p>';\n  }\n}\n/**\n * Compute the average value of the property contained on the source.\n */\nexport function calculateTrendByProperties(source: any[], properties: string[]): string {\n  const arraysum = extractArraySum(source, properties);\n\n  const lastProp = arraysum.length > 0 ? arraysum[arraysum.length - 1] || 0 : 0;\n  const lastLastProp = arraysum.length > 1 ? arraysum[arraysum.length - 2] || 0 : lastProp;\n\n  if (lastProp == lastLastProp) {\n    return '<p><i class=\"material-icons\" style=\"color:blue\">trending_flat</i></p>';\n  } else if (lastProp > lastLastProp) {\n    return '<p><i class=\"material-icons\" style=\"color:green\">trending_up</i></p>';\n  } else {\n    return '<p><i class=\"material-icons\" style=\"color:red\">trending_down</i></p>';\n  }\n}\n/**\n *\n */\nexport function calculateAvgProperty(\n  source: any[],\n  property: string,\n  range: number,\n  coefficient: number,\n): number {\n  source = (source || []).slice(0);\n\n  coefficient = coefficient || 1;\n  range = range || 12;\n\n  let l = source.length;\n  let res = 0;\n  let counter = 0;\n  let noZero = 0;\n\n  if (l < range) {\n    range = l;\n  }\n\n  while (range != 0) {\n    if (source[l - 1][property] != null) {\n      counter++;\n      res += Number(source[l - 1][property]);\n\n      if (source[l - 1][property] > 0) {\n        noZero++;\n      }\n    }\n    l--;\n    range--;\n  }\n\n  if (coefficient == 0) {\n    return noZero;\n  } else {\n    return round((res / counter) * coefficient, 2) || 0;\n  }\n}\n\nexport function calculateAvgPropertyArray(\n  source: any[],\n  properties: string[],\n  range: number,\n  coefficient: number,\n): number[] {\n  source = (source || []).slice(0);\n  const resArr: any[] = [];\n\n  if (properties && properties.length > 0) {\n    let avg = 0;\n\n    coefficient = coefficient || 1;\n    range = range || 12;\n\n    const sourceArr =\n      properties.length > 1\n        ? extractArraySum(source, properties)\n        : extractArray(source, properties[0]);\n\n    let l = sourceArr.length;\n\n    for (let len = l; len > 0; len--) {\n      let res = 0;\n      let counter = 0;\n      let noZero = 0;\n\n      if (len < range) {\n        range = len;\n      }\n\n      for (let r = 1; r <= range; r++) {\n        let val = sourceArr[len - r];\n        if (val != null) {\n          counter++;\n          res += Number(val);\n          if (val > 0) {\n            noZero++;\n          }\n        }\n      }\n\n      if (counter > 0) {\n        if (coefficient == 0) {\n          avg = noZero;\n        } else {\n          avg = (res / counter) * coefficient || 0;\n        }\n        resArr.push(round(avg, 2));\n      }\n    }\n  }\n  return resArr.reverse();\n}\n\nexport function alert(source: any[], property: string, threshold: number): string {\n  source = (source || []).slice(0);\n\n  if (lastProperty(source, property) > threshold) {\n    return '<p><i class=\"material-icons\" style=\"color:red\">warning</i></p>';\n  } else {\n    return '<p></p>';\n  }\n}\n\nexport function formatNumber(num: number, fmt?: string): string {\n  fmt = fmt || '0,0[.]0';\n  return numbro(num).format(fmt);\n}\n\nexport function formatDate(date: Date | string, fmt?: string): string {\n  fmt = fmt || 'mm-DD-yyyy';\n  return dateUtils.format(typeof date === 'string' ? dateUtils.parse(date) : date, fmt);\n}\n\nexport function isoMonth(date: Date, fmt?: string): string {\n  fmt = fmt || 'mm';\n  const du = dateUtils;\n  return du.format(du.addDays(du.startOfISOWeek(date), 3), fmt);\n}\n\nexport function getCoordinate(source: any, zoom?: number): [number, number, number] {\n  zoom = zoom || 6;\n  if (source == null) {\n    return [51.505, -0.09, zoom];\n  } else {\n    return [source[0], source[1], zoom];\n  }\n}\n\n/**\n * Calculates all the possible results that a field has taken\n */\nexport function ALL_VALUES_OF(mainforms: MainForm[], fieldName: string): string[] {\n  const allreps = (mainforms || [])\n    .slice(0)\n    .map(m => m.reps)\n    .filter(c => c != null)\n    .map((i: unknown) =>\n      Object.keys(i as Instances)\n        .map(k => (i as Instances)[k])\n        .flat(),\n    )\n    .flat();\n\n  return [...new Set(allreps.filter(f => f[fieldName] != null).map(f => `${f[fieldName]}`))];\n}\nexport function plainArray(params: any[]): any[] {\n  let res: any[] = [];\n  params.forEach(param => {\n    param = Array.isArray(param) ? param : [param];\n    res = [...res, ...param];\n  });\n\n  return res;\n}\n/**\n * Counts the collected forms. The form name must be specified. An optional condition can be added\n * to discriminate which forms to count in.\n * the expression is first evaluated in mainForm if false the evaluation of expression is calculated\n * in any reps. If expression is true in reps the form is counted\n */\nexport function COUNT_FORMS(formList: MainForm[], expression: string = 'true'): number {\n  // const forms: MainForm[] = deepCopy(formList).filter((f: MainForm) => f != null);\n  const forms: MainForm[] = (formList || []).slice(0).filter((f: MainForm) => f != null);\n  const identifiers = [...new Set(getCodeIdentifiers(expression, true))];\n  let count = 0;\n  if (expression === 'true') {\n    return forms.length;\n  }\n  if (forms.length === 0) {\n    return 0;\n  }\n  for (let i = 0; i < forms.length; i++) {\n    const mainForm = forms[i];\n    let exxpr = expression;\n    identifiers.forEach(identifier => {\n      const change = mainForm[identifier] ? mainForm[identifier] : null;\n      if (change != null) {\n        exxpr = exxpr.split(identifier).join(JSON.stringify(change as string));\n      }\n    });\n    if (mainForm.reps != null) {\n      const allreps: number = Object.keys(mainForm.reps)\n        .map((key: string) => (mainForm.reps as Instances)[key])\n        .flat()\n        .map((child: Form) => evaluateExpression(exxpr, child))\n        .reduce((a, b) => (a += +b), 0);\n      if (allreps > 0) {\n        count++;\n      }\n    }\n\n    if (evaluateExpression(exxpr, mainForm)) {\n      count++;\n    }\n  }\n  return count;\n}\n/**\n * Counts the reps of the form.\n * the expression is first evaluated in mainForm  if true return all reps counting else the evaluation of expression is calculated\n * in any reps and return the count of all reps that satisfied the expression.\n */\nexport function COUNT_REPS(formList: MainForm[], expression: string = 'true'): number {\n  const forms: MainForm[] = cloneMainForms(formList).filter((f: MainForm) => f != null);\n  const identifiers = getCodeIdentifiers(expression, true);\n  let exxpr = expression;\n  let count = 0;\n\n  if (forms.length === 0) {\n    return 0;\n  }\n  for (let i = 0; i < forms.length; i++) {\n    const mainForm = forms[i];\n    if (mainForm.reps != null) {\n      const allreps: Form[] = Object.keys(mainForm.reps)\n        .map((key: string) => (mainForm.reps as Instances)[key])\n        .flat();\n      allreps.forEach((child: Form) => {\n        if (evaluateExpression(expression, child)) {\n          count++;\n        }\n      });\n    }\n\n    identifiers.forEach(identifier => {\n      const change = mainForm[identifier] ? mainForm[identifier] : null;\n      if (change) {\n        exxpr = expression.split(identifier).join(JSON.stringify(change as string));\n      }\n    });\n    if (evaluateExpression(exxpr, mainForm)) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Counts the amount of unique form values for a specific field. The form name must be specified. An\n * optional condition can be added to discriminate which forms to count in\n */\nexport function COUNT_FORMS_UNIQUE(\n  formList: MainForm[],\n  fieldName: string,\n  expression: string = 'true',\n): number {\n  const forms: MainForm[] = (formList || []).slice(0).filter((f: MainForm) => f != null);\n  const identifiers = [...new Set(getCodeIdentifiers(expression, true))];\n  let values: any[] = [];\n\n  if (forms.length === 0) {\n    return 0;\n  }\n  for (let i = 0; i < forms.length; i++) {\n    const mainForm = forms[i];\n    let exxpr = expression;\n    identifiers.forEach(identifier => {\n      const change = mainForm[identifier] ? mainForm[identifier] : null;\n      if (change != null) {\n        exxpr = exxpr.split(identifier).join(JSON.stringify(change as string));\n      }\n    });\n    if (mainForm.reps != null) {\n      const fieldNameInMain = evaluateExpression(fieldName, mainForm);\n      const allreps: any[] = Object.keys(mainForm.reps)\n        .map((key: string) => (mainForm.reps as Instances)[key])\n        .flat()\n        .filter((child: Form) => evaluateExpression(exxpr, child))\n        .map((child: Form) =>\n          fieldNameInMain != null ? fieldNameInMain : evaluateExpression(fieldName, child),\n        );\n      if (allreps.length > 0) {\n        values = [...values, ...allreps];\n      }\n    }\n    if (evaluateExpression(exxpr, mainForm)) {\n      const mValue = evaluateExpression(fieldName, mainForm);\n      if (mValue != null) {\n        values.push(mValue);\n      }\n    }\n  }\n  return [...new Set(values)].length;\n}\n\n/**\n * Aggregates and sums the values of one or more. An optional condition can be added to discriminate\n * which forms to take for the sum.\n */\nexport function SUM(mainForms: (MainForm | Form)[], field: string, condition = 'true'): number {\n  // const forms: MainForm[] = deepCopy(mainForms).filter((f: MainForm) => f != null);\n  const forms: (MainForm | Form)[] = (mainForms || [])\n    .slice(0)\n    .filter((f: MainForm | Form) => f != null);\n  const identifiers = getCodeIdentifiers(condition, true);\n  let exxpr = condition;\n  let count = 0;\n\n  if (forms.length === 0) {\n    return 0;\n  }\n  for (let i = 0; i < forms.length; i++) {\n    const mainForm = forms[i];\n    if (mainForm.reps != null) {\n      const allreps: Form[] = Object.keys(mainForm.reps)\n        .map((key: string) => (mainForm.reps as Instances)[key])\n        .flat();\n      allreps\n        .filter(c => c[field] != null)\n        .forEach((child: Form) => {\n          if (evaluateExpression(condition, child)) {\n            count += +(child[field] as number) || 0;\n          }\n        });\n    }\n\n    identifiers.forEach(identifier => {\n      const change = mainForm[identifier] ? mainForm[identifier] : null;\n      if (change) {\n        exxpr = condition.split(identifier).join(JSON.stringify(change) as string);\n      }\n    });\n    if (evaluateExpression(exxpr, mainForm) && mainForm[field] != null) {\n      count += +(mainForm[field] as number) || 0;\n    }\n  }\n  return count;\n}\n\n/**\n * Calculates the mean of a simple or derived value. An optional condition can be added to\n * discriminate which forms to take for the sum.\n */\nexport function MEAN(forms: (Form | MainForm)[], fieldName: string): string {\n  forms = (forms || []).slice(0);\n  fieldName = fieldName || '';\n  let length = 0;\n  let acc = 0;\n  forms.forEach(form => {\n    if (form[fieldName] == null && form.reps != null) {\n      Object.keys(form.reps as Instances).forEach(rep => {\n        ((form.reps as Instances)[rep] as Form[]).forEach(rform => {\n          const rsVal = rform[fieldName];\n          if (rsVal != null) {\n            acc += evaluateExpression(`${rsVal}`, form);\n            length++;\n          }\n        });\n      });\n    } else {\n      acc += evaluateExpression(fieldName, form);\n      length++;\n    }\n  });\n  return `${ROUND(acc / length)}`;\n}\n\n/**\n * Calculates the % between two members.\n */\nexport function PERCENT(value1: number, value2: number): string {\n  const res = (+value1 * 100) / +value2;\n  return Number.isFinite(res) ? `${ROUND(res)}%` : 'infinite';\n}\n\n/**\n * Calculates the expression in the last form by date.\n */\nexport function LAST(forms: (Form | MainForm)[], expression: string, date = 'date_end'): string {\n  forms = (forms || []).slice(0).sort((a, b) => {\n    const dateA = new Date(b[date] as string).getTime();\n    const dateB = new Date(a[date] as string).getTime();\n    return dateA - dateB;\n  });\n  if (forms.length > 0 && expression != null) {\n    const identifiers = getCodeIdentifiers(expression, true);\n    const lastForm = forms[forms.length - 1] || [];\n    let exxpr = expression;\n    identifiers.forEach(identifier => {\n      const change = lastForm[identifier] ? lastForm[identifier] : null;\n      if (change != null) {\n        exxpr = exxpr.split(identifier).join(change as string);\n      }\n    });\n    const formEval = evaluateExpression(expression, lastForm);\n    if (formEval == false && lastForm.reps != null) {\n      const allreps: number = Object.keys(lastForm.reps)\n        .map((key: string) => (lastForm.reps as Instances)[key])\n        .flat()\n        .map((rep: Form) => evaluateExpression(exxpr, rep))\n        .reduce((a, b) => (a += +b), 0);\n      if (allreps > 0) {\n        return `${allreps}`;\n      }\n    }\n    return formEval;\n  }\n  return '0';\n}\n\n/**\n * Calculates the max value of the field.\n */\nexport function MAX(forms: (Form | MainForm)[], fieldName: string): number {\n  forms = (forms || []).slice(0);\n  let max = 0;\n  forms.forEach(form => {\n    if (form[fieldName] == null && form.reps != null) {\n      Object.keys(form.reps as Instances).forEach(rep => {\n        ((form.reps as Instances)[rep] as Form[]).forEach(rform => {\n          if (\n            form[fieldName] != null &&\n            !isNaN(form[fieldName] as number) &&\n            (form[fieldName] as number) > max\n          ) {\n            max = form[fieldName] as number;\n          }\n        });\n      });\n    } else {\n      if (\n        form[fieldName] != null &&\n        !isNaN(form[fieldName] as number) &&\n        (form[fieldName] as number) > max\n      ) {\n        max = form[fieldName] as number;\n      }\n    }\n  });\n  return max;\n}\n\n/**\n * Calculates the median value of the field.\n */\nexport function MEDIAN(forms: (Form | MainForm)[], fieldName: string): string {\n  forms = (forms || []).slice(0);\n  let numbers: number[] = [];\n  forms.forEach(form => {\n    if (form[fieldName] == null && form.reps != null) {\n      Object.keys(form.reps as Instances).forEach(rep => {\n        ((form.reps as Instances)[rep] as Form[]).forEach(rform => {\n          if (rform[fieldName] != null) {\n            numbers.push(rform[fieldName] as number);\n          }\n        });\n      });\n    } else {\n      numbers.push((form as Form)[fieldName] as number);\n    }\n  });\n\n  numbers = numbers.sort((a, b) => a - b).filter((item, pos, self) => self.indexOf(item) == pos);\n  const res = Number.isInteger(numbers.length / 2)\n    ? numbers[numbers.length / 2]\n    : (numbers[+parseInt(`${numbers.length - 1 / 2}`) / 2] +\n        numbers[+parseInt(`${numbers.length - 1 / 2}`) / 2 + 1]) /\n      2;\n\n  return `${ROUND(res)}`;\n}\n\n/**\n * Calculates the mode value of the field.\n */\nexport function MODE(forms: (Form | MainForm)[], fieldName: string): number[] {\n  forms = (forms || []).slice(0);\n  let maxCount = 0;\n  const map: {[key: number]: number} = {};\n  forms.forEach(f => {\n    if (f[fieldName] == null && f.reps != null) {\n      Object.keys(f)\n        .filter(key => key.includes(fieldName))\n        .forEach(rsField => {\n          const value = f[rsField] as number;\n          if (value != null) {\n            map[value] = map[value] != null ? map[value] + 1 : 1;\n          }\n          if (map[value] > maxCount) {\n            maxCount = map[value];\n          }\n        });\n    } else {\n      const value = f[fieldName] as number;\n      if (value != null) {\n        map[value] = map[value] != null ? map[value] + 1 : 1;\n      }\n      if (map[value] > maxCount) {\n        maxCount = map[value];\n      }\n    }\n  });\n  return Object.keys(map)\n    .filter(v => map[+v] === maxCount)\n    .map(v => +v);\n}\n\nexport function buildDataset(\n  dataset: (string | number | string[] | number[])[],\n  colspans: number[],\n): AjfTableCell[][] {\n  const res: AjfTableCell[][] = [];\n  const normalizeDataset: any[][] = [];\n  dataset.forEach((row: any, indexRow: number) => {\n    row = Array.isArray(row) ? row : [row];\n    normalizeDataset[indexRow % colspans.length] =\n      normalizeDataset[indexRow % colspans.length] != null\n        ? [...normalizeDataset[indexRow % colspans.length], ...row]\n        : [...row];\n  });\n  const transpose = normalizeDataset[0].map((_: any, colIndex: number) =>\n    normalizeDataset.map((row: any) => row[colIndex]),\n  );\n  transpose.forEach((data: any[], index: number) => {\n    const row: AjfTableCell[] = [];\n    data.forEach((cellValue: string | number, cellIndex: number) => {\n      row.push({\n        value: cellValue,\n        colspan: colspans[cellIndex],\n        rowspan: 1,\n        style: {\n          textAlign: 'center',\n          color: 'black',\n          backgroundColor: index % 2 === 0 ? 'white' : '#ddd',\n        },\n      });\n    });\n    res.push(row);\n  });\n  return res;\n}\n\n/**\n *\n * @param forms the form data\n * @param iterations all values of iteration\n * @param fn the fuction of expression-utils to apply at iteration\n * @param param1 first param of fn\n * @param param2 second param of fn\n * @returns the result of fn applied to all values param conditions\n * &current is an anchor key, The params with &current will be modified with the iteration values.\n */\nexport function REPEAT(\n  forms: MainForm[],\n  iterations: string[],\n  fn: AjfValidationFn,\n  param1: string,\n  param2: string = 'true',\n): any[] {\n  const res: any[] = [];\n  const newExp1 =\n    param1 != null && param1.includes('current')\n      ? (v: any) => param1.split('current').join(JSON.stringify(v))\n      : () => param1;\n  const newExp2 =\n    param2 != null && param2.includes('current')\n      ? (v: any) => param2.split('current').join(JSON.stringify(v))\n      : () => param2;\n  iterations.forEach(v => {\n    const vv = (fn as any)(forms, newExp1(v), newExp2(v));\n    res.push(vv);\n  });\n  return res;\n}\nfunction buildFn(expression: string): any {\n  return (v: any) => {\n    const newExp = expression\n      .split('ajf_form')\n      .join(`${JSON.stringify(v)}`)\n      .split('current')\n      .join(`${JSON.stringify(v)}`);\n    return newExp;\n  };\n}\n\n/**\n * this function allow to define a new attribute of mainform.\n * the attribute field will be added on every form and it takes the result of expression calculated\n * for every mainform\n *\n * @export\n * @param {MainForm[]} formList\n * @param {string} field\n * @param {string} expression\n * @return {*}  {MainForm[]}\n */\nexport function APPLY(formList: MainForm[], field: string, expression: string): MainForm[] {\n  const expFn = buildFn(expression);\n  formList = cloneMainForms(formList);\n\n  for (let i = 0; i < formList.length; i++) {\n    if (formList[i] == null) {\n      continue;\n    }\n    if (formList[i].reps != null) {\n      formList[i][field] = evaluateExpression(expFn(formList[i]), formList[i]);\n    }\n  }\n  return formList;\n}\n\n/**\n * this function round a number,\n * if you need can be define de digits of round\n *\n * @export\n * @param {(number | string)} num\n * @param {number} [digits]\n * @return {*}  {number}\n */\nexport function ROUND(num: number | string, digits?: number): number {\n  return round(num, digits);\n}\n\n/**\n * this function evalueate a condition if true return branch1 else branch2\n *\n * @export\n * @param {string} condition\n * @param {*} branch1\n * @param {*} branch2\n * @return {*}  {*}\n */\nexport function EVALUATE(condition: string, branch1: any, branch2: any): any {\n  if (evaluateExpression(condition)) {\n    return branch1;\n  } else {\n    return branch2;\n  }\n}\n/**\n * This function builds a data structure that allows the use of the hindikit formulas\n * for every forms with repeating slides.\n * In particular, it builds a main data form with all the data relating to the slides and\n * a dictionary with the name reps thus made instance slideName forms.\n * Where a form is associated with each instance of the repeating slide.\n * example:\n * simple form:\n *  {\n *    $value: \"AGO\"\n *    cittadinanza__0: \"AGO\"\n *    codice_fiscale__0: \"jdfljglòkòkò\"\n *    country__0: \"AGO\"\n *    date_end: \"2021-01-10\"\n *    date_start: \"2021-01-10\"\n *    dob__0: \"2021-03-11\"\n *    first_name__0: \"pippo\"\n *    gender__0: \"f\"\n *    id_family: \"3bef3a3f-d95d-4a09-8df4-e812c55c61c6\"\n *    istruzione__0: null\n *    last_name__0: \"pippo\"\n *    permesso_soggiorno__0: \"no\"\n *    relazione__0: \"genitore\"\n *    solidando: \"solidando1\"\n *    stato_civile__0: null\n *  }\n * after BUILD_DATASET\n * MainForm:\n * {\n *    $value: \"AGO\"\n *    ajf_form_id: 0 ** added atribute that rappresent the index position insides input form list.\n *    ajf_family_component_count: 1** added atribute that rappresent the instance number of famili_component repeating slides.\n *    date_end: \"2021-01-10\"\n *    date_start: \"2021-01-10\"\n *    id_family: \"3bef3a3f-d95d-4a09-8df4-e812c55c61c6\"\n *    reps: {\n *      family_component: [\n *        {\n *          ajf_family_component_rep: 0 ** added atribute that rappresent the order instance of family_component repeating slide.\n *          cittadinanza: \"AGO\"\n *          codice_fiscale: \"jdfljglòkòkò\"\n *          country: \"AGO\"\n *          dob: \"2021-03-11\"\n *          first_name: \"pippo\"\n *          gender: \"f\"\n *          istruzione: null\n *          last_name: \"pippo\"\n *          permesso_soggiorno: \"no\"\n *          relazione: \"genitore\"\n *          stato_civile: null\n *        }\n *      ]\n *    }\n * }\n *\n * @param {Form[]} forms\n * @param {*} [schema] if schema is provided the instances inside the reps match with effective\n * slide name. Otherwise all repeating slides are associates to generic slide name \"rep\".\n * @return {*}  {MainForm[]}\n */\nexport function BUILD_DATASET(forms: Form[], schema?: any): MainForm[] {\n  const res: MainForm[] = [];\n  const generateMetadata = (slideName: string, slideInstance: number) => {\n    const resg: {[sname: string]: any} = {};\n    resg[`ajf_${slideName}_rep`] = slideInstance;\n    return resg;\n  };\n\n  forms = (forms || []).slice(0);\n\n  if (schema != null) {\n    const repeatingSlides: any[] = schema.nodes.filter((node: any) => node.nodeType === 4);\n    const obj: {[fieldName: string]: string} = {};\n    repeatingSlides.forEach(slide => {\n      let nodeFields = slide.nodes.map((n: any) => n.name);\n      nodeFields.forEach((nodeField: string) => {\n        obj[nodeField] = slide.name;\n      });\n    });\n    forms.forEach((f, formIdx) => {\n      const mainForm: MainForm = {reps: {}};\n      const fKeys: string[] = Object.keys(f);\n      const instances: {[slideName: string]: any} = {};\n\n      fKeys.forEach(fkey => {\n        const splittedKey: string[] = fkey.split('__');\n        const splittedLength: number = splittedKey.length;\n        const fieldName = splittedKey[0];\n        const slideInstance =\n          splittedKey[1] != null && Number.isInteger(+splittedKey[1]) ? +splittedKey[1] : null;\n        const slideName = obj[fieldName];\n        if (splittedLength === 2 && slideInstance != null && slideName != null) {\n          instances[slideName] = instances[slideName] != null ? instances[slideName] : [];\n          instances[slideName][slideInstance] =\n            instances[slideName][slideInstance] != null\n              ? instances[slideName][slideInstance]\n              : generateMetadata(slideName, slideInstance);\n          instances[slideName][slideInstance][fieldName] = f[fkey];\n        } else {\n          mainForm[fieldName] = f[fieldName];\n        }\n      });\n      mainForm[`ajf_form_id`] = formIdx;\n      const instanceKeys = Object.keys(instances);\n      instanceKeys.forEach(instanceKey => {\n        mainForm[`ajf_${instanceKey}_count`] = instances[instanceKey].length;\n      });\n      mainForm.reps = instances;\n      res.push(mainForm);\n    });\n    return res;\n  } else {\n    forms.forEach(form => {\n      const fKeys: string[] = Object.keys(form);\n      const noRepeatingFields: string[] = fKeys.filter(fkey => fkey.indexOf('__') === -1);\n      const noRepForm: Form = {};\n\n      noRepeatingFields.forEach(field => {\n        noRepForm[field] = form[field];\n      });\n\n      const mainForm: MainForm = {...noRepForm, reps: {slide: []}};\n\n      for (let i = 0; i <= MAX_REPS; i++) {\n        const currentSlide: Form = {};\n        const onlyCurrentInstanceKeys: string[] = fKeys.filter(fkey => fkey.indexOf(`__${i}`) > -1);\n        // se il numero di attributi coincide il form data non ha repeatingslides\n        if (onlyCurrentInstanceKeys.length === 0) {\n          mainForm['ajf_rep_count'] = i;\n          break;\n        }\n        onlyCurrentInstanceKeys.forEach(key => {\n          const splittedKey = key.split('__');\n          const fieldName = splittedKey[0];\n          const slideInstance = splittedKey[1] != null ? +splittedKey[1] : null;\n          currentSlide[fieldName] = form[key];\n          currentSlide['ajf_rep'] = slideInstance != null ? slideInstance : currentSlide['ajf_rep'];\n        });\n        if (onlyCurrentInstanceKeys.length != 0) {\n          mainForm.reps!.slide.push(currentSlide);\n        } else {\n          mainForm.reps = undefined;\n        }\n      }\n      res.push(mainForm);\n    });\n\n    return res;\n  }\n}\n\n/**\n * This function build a partition of formList by execution of expression.\n * For every mainForm the expression match mainform field and replace it.\n * If the evaluation of expression is true the mainForm was added to partition\n * (that becouse the expression don't has repeating slide fields) else if\n * there are reps for every rep the expression is updated with replacing of\n * repeating slide instance fields and evaluated, if true was added to partition.\n * All ajf attributes wad updated. /TODO\n *\n *\n * @param {MainForm[]} formList a set of main forms\n * @param {string} expression to be evaluated. that can be able to contains another\n * hindikit functions or mainForm fields or reps fields.\n * @return {*}  {MainForm[]}\n */\nexport function FILTER_BY(formList: MainForm[], expression: string): MainForm[] {\n  const forms: MainForm[] = cloneMainForms(formList || []).filter((f: MainForm) => f != null);\n  const identifiers = [...new Set(getCodeIdentifiers(expression, true))];\n  let res: MainForm[] = [];\n  if (expression === 'true') {\n    return forms;\n  }\n  if (forms.length === 0) {\n    return [];\n  }\n\n  for (let i = 0; i < forms.length; i++) {\n    const mainForm: MainForm = forms[i];\n    let expr = expression;\n    if (mainForm == null) {\n      res.push(mainForm);\n      continue;\n    }\n    /* replace main form field inside expression */\n    identifiers.forEach(identifier => {\n      const change = mainForm[identifier] ? mainForm[identifier] : null;\n      if (change) {\n        expr = expr.split(identifier).join(JSON.stringify(change));\n      }\n    });\n    /* if that's already true push it in res */\n    if (evaluateExpression(expr, mainForm)) {\n      res.push(mainForm);\n      continue;\n    }\n\n    let newReps: Instances | undefined;\n    const childKeys = Object.keys(mainForm.reps as Instances);\n\n    childKeys.forEach(childKey => {\n      const currentReps = ((mainForm.reps as Instances)[childKey] as Form[])\n        .filter((form: Form) => {\n          let repExpr = expr;\n          /* replace rep field inside expression */\n          identifiers.forEach(identifier => {\n            const changeInRep = form[identifier] ? form[identifier] : null;\n            if (changeInRep) {\n              repExpr = repExpr.split(identifier).join(JSON.stringify(changeInRep));\n            }\n          });\n          return evaluateExpression(repExpr, form);\n        })\n        .filter(f => f != null);\n      if (currentReps.length > 0) {\n        newReps = (newReps != null ? newReps : {}) as Instances;\n        newReps[childKey] = currentReps;\n      }\n      mainForm[`ajf_${childKey}_count`] = currentReps.length;\n    });\n    if (newReps == null) {\n      res.push(null as unknown as MainForm);\n    } else {\n      mainForm.reps = newReps;\n      res.push(mainForm);\n    }\n  }\n\n  return res;\n}\n\n/**\n * return the today date\n *\n * @export\n * @param {string} [format='yyyy-MM-dd']\n * @return {*}  {string}\n */\nexport function TODAY(format = 'yyyy-MM-dd'): string {\n  return dateFns.format(new Date(), format);\n}\n\n/**\n * UTILITY FUNCTION\n *  this function allow the console log of excel variables.\n * @export\n * @param {*} val\n * @param {string} [text='log: ']\n */\nexport function CONSOLE_LOG(val: any, text = 'log: '): void {\n  console.log(text, val);\n}\n\n/**\n * this function take a string date and return the difference in year from dob to today.\n *\n * @export\n * @param {(string | null)} dob\n * @return {*}  {number}\n */\nexport function GET_AGE(dob: string | null): number {\n  if (dob == null) return +'<'; // need for generate false funcion in evaluateExpression\n  const date = new Date(dob);\n  const age: number = dateFns.differenceInYears(new Date(), date);\n  return age;\n}\n\n/**\n * this function returns reps length if reps in defined or the length of dataset if dataset is array-\n *\n * @export\n * @param {(MainForm | any[])} dataset\n * @return {*}  {number}\n */\nexport function LEN(dataset: MainForm | any[]): number {\n  if (dataset == null) {\n    return 0;\n  }\n  if ((dataset as MainForm).reps != null) {\n    const mainForm = dataset as MainForm;\n    const reps = Object.keys(mainForm.reps as Instances)\n      .map(key => (mainForm.reps as Instances)[key].flat())\n      .flat();\n    return reps.length;\n  }\n\n  return (dataset as any[]).length || 0;\n}\n\n/**\n * return true if date is before then dateToCompare\n *\n * @export\n * @param {string} date\n * @param {string} dateToCompare\n * @return {*}  {boolean}\n */\nexport function IS_BEFORE(date: string, dateToCompare: string): boolean {\n  const dateA: Date = dateFns.parseISO(date);\n  const dateB: Date = dateFns.parseISO(dateToCompare);\n  return dateFns.isBefore(dateA, dateB);\n}\n\n/**\n * return true if date is after then dateToCompare\n *\n * @export\n * @param {string} date\n * @param {string} dateToCompare\n * @return {*}  {boolean}\n */\nexport function IS_AFTER(date: string, dateToCompare: string): boolean {\n  const dateA: Date = dateFns.parseISO(date);\n  const dateB: Date = dateFns.parseISO(dateToCompare);\n  return dateFns.isAfter(dateA, dateB);\n}\n\n/**\n * return true if date is whithin interval from dateStart to dateEnd\n *\n * @export\n * @param {string} date\n * @param {string} dateStart\n * @param {string} dateEnd\n * @return {*}  {boolean}\n */\nexport function IS_WITHIN_INTERVAL(date: string, dateStart: string, dateEnd: string): boolean {\n  const dateToCompare: Date = dateFns.parseISO(date);\n  const interval: Interval = {start: dateFns.parseISO(dateStart), end: dateFns.parseISO(dateEnd)};\n  return dateFns.isWithinInterval(dateToCompare, interval);\n}\n\n/**\n * this function extend formsA dataset.\n * search all match of keyA in formsB, if found if merge formA and formB.\n *\n * @export\n * @param {string} keyA\n * @param {string} [keyB]\n * @return {*}\n */\nexport function JOIN_FORMS(\n  formsA: (MainForm | Form)[],\n  formsB: (MainForm | Form)[],\n  keyA: string,\n  keyB?: string,\n): (MainForm | Form)[] {\n  formsA = cloneMainForms(formsA);\n  formsB = cloneMainForms(formsB);\n  const mergedForms: (MainForm | Form)[] = [];\n  if (keyA == null || formsA == null || formsA.length === 0) {\n    return mergedForms;\n  }\n  if (keyB == null) {\n    keyB = keyA;\n  }\n  if (formsB == null || formsB.length === 0) {\n    return formsA;\n  }\n  for (let i = 0; i < formsA.length; i++) {\n    const formA = formsA[i];\n    const keyAValue = formA[keyA];\n    let mergedForm = {...formA};\n    if (formA == null || keyAValue == null) {\n      mergedForms.push(formA);\n      continue;\n    }\n    for (let j = 0; j < formsB.length; j++) {\n      const formB = formsB[j];\n      const keyBValue = formB[keyB];\n      if (formB == null || keyBValue == null) {\n        continue;\n      }\n      if (keyAValue === keyBValue) {\n        mergedForm = {...formA, ...formB};\n        if (formA.reps != null && formB.reps != null) {\n          mergedForm.reps = {...(formA as MainForm).reps, ...(formB as MainForm).reps};\n        }\n        break;\n      }\n    }\n    mergedForms.push(mergedForm);\n  }\n\n  return mergedForms;\n}\n\n/**\n * like JOIN_FORMS but extends the behaviour on the reps.\n * search all match of subKeyA in formB\n *\n * @export\n * @param {MainForm[]} formsA\n * @param {MainForm[]} formsB\n * @param {string} keyA\n * @param {string} keyB\n * @param {string} subKeyA\n * @param {string} [subKeyB]\n * @return {*}  {MainForm[]}\n */\nexport function JOIN_REPEATING_SLIDES(\n  formsA: MainForm[],\n  formsB: MainForm[],\n  keyA: string,\n  keyB: string,\n  subKeyA: string,\n  subKeyB?: string,\n): MainForm[] {\n  const mergedForms: MainForm[] = [];\n  formsA = cloneMainForms(formsA);\n  formsB = cloneMainForms(formsB);\n  if (keyA == null || formsA == null || formsA.length === 0) {\n    return mergedForms;\n  }\n  if (keyB == null) {\n    keyB = keyA;\n  }\n  if (formsB == null || formsB.length === 0) {\n    return formsA;\n  }\n  if (subKeyA == null) {\n    return JOIN_FORMS(formsA, formsB, keyA, keyB) as MainForm[];\n  }\n  if (subKeyB == null) {\n    subKeyB = subKeyA;\n  }\n  for (let i = 0; i < formsA.length; i++) {\n    const formA = formsA[i];\n    const keyAValue = formA[keyA];\n    let mergedForm = {...formA};\n    if (formA == null || keyAValue == null) {\n      mergedForms.push(formA);\n      continue;\n    }\n    for (let j = 0; j < formsB.length; j++) {\n      const formB = formsB[j];\n      const keyBValue = formB[keyB];\n      if (formB == null || keyBValue == null) {\n        continue;\n      }\n      if (keyAValue === keyBValue) {\n        mergedForm = {...formA, ...formB};\n        mergedForm.reps = {...formA.reps, ...formB.reps};\n        if (formA.reps != null && formB.reps != null) {\n          const mergedReps: Instances = {};\n          const childAKeys = Object.keys(formA.reps);\n          const childB = Object.keys(formB.reps)\n            .map(key => (formB.reps as Instances)[key].flat())\n            .flat();\n          childAKeys.forEach(key => {\n            const instance = (formA.reps as Instances)[key];\n            mergedReps[key] = JOIN_FORMS(\n              instance as unknown as MainForm[],\n              childB as unknown as MainForm[],\n              subKeyA,\n              subKeyB,\n            ) as Form[];\n          });\n          mergedForm.reps = mergedReps;\n        }\n        break;\n      }\n    }\n    mergedForms.push(mergedForm);\n  }\n\n  return mergedForms;\n}\n\n/**\n * this function extract an array of evaluated expression from main form reps.\n *\n * @export\n * @param {MainForm} mainForm\n * @param {string} expression\n * @return {*}  {any[]}\n */\nexport function FROM_REPS(mainForm: MainForm, expression: string): any[] {\n  const res: any[] = [];\n\n  if (mainForm != null && mainForm.reps != null) {\n    const reps = Object.keys(mainForm.reps)\n      .map(key => (mainForm.reps as Instances)[key].flat())\n      .flat();\n    reps.forEach(child => {\n      res.push(evaluateExpression(expression, child));\n    });\n  }\n\n  return res;\n}\n\n/**\n * this function return true if value is inside of dataset\n *\n * @export\n * @param {any[]} dataset\n * @param {*} value\n * @return {*}  {boolean}\n */\nexport function ISIN(dataset: any[], value: any): boolean {\n  if (dataset == null || value == null) {\n    return false;\n  }\n  return dataset.indexOf(value) >= 0;\n}\n\n/**\n * the lengths of the datasets are assumed to be the same.\n * this function return an array list of calculated values.\n * each element of the array is calculated by replacing elemA with the current element of a\n * and elemB with the current element of b inside the expression.\n *\n * @export\n * @param {number[]} datasetA\n * @param {number[]} datasetB\n * @param {string} expression\n * @return {*}  {number[]}\n */\nexport function OP(datasetA: number[], datasetB: number[], expression: string): number[] {\n  const res: number[] = [];\n  if (datasetA == null || datasetB.length > datasetA.length) {\n    return [];\n  }\n  if (datasetB == null) {\n    return datasetA;\n  }\n  for (let i = 0; i < datasetA.length; i++) {\n    const elemA = datasetA[i] || 0;\n    const elemB = datasetB[i] || 0;\n    const expr = expression\n      .split('elemA')\n      .join(JSON.stringify(elemA))\n      .split('elemB')\n      .join(JSON.stringify(elemB));\n    res.push(evaluateExpression(expr));\n  }\n\n  return res;\n}\n\n/**\n * this function take a ajf schema and a list of field names as input and\n * returns a list of label matched inside a schema choiche origins.\n *\n * @export\n * @param {*} schema\n * @param {string[]} fieldNames\n * @return {*}  {string[]}\n */\nexport function GET_LABELS(schema: any, fieldNames: string[]): string[] {\n  const labels: {[fieldName: string]: string} = {};\n\n  if (schema != null && schema.choicesOrigins != null) {\n    (schema.choicesOrigins as any[]).forEach(choice => {\n      if (choice != null && choice.choices != null) {\n        (choice.choices as any[]).forEach(element => {\n          labels[element.value] = element.label;\n        });\n      }\n    });\n  }\n\n  return fieldNames.map(fieldName => (labels[fieldName] != null ? labels[fieldName] : fieldName));\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfContext} from '@ajf/core/common';\n\nimport {AjfExpressionUtils} from './expression-utils';\n\nexport function getContextString(context?: AjfContext): string {\n  let fstr = AjfExpressionUtils.UTIL_FUNCTIONS;\n  if (context instanceof Array) {\n    for (let i = 0; i < context.length; i++) {\n      fstr = `${fstr}var ${context[i]} = true;`;\n    }\n  } else if (context != null) {\n    Object.keys(context).forEach(x => {\n      let val: any = context[x];\n      if (val == null || isNaN(Number(val)) || val === '' || val instanceof Array) {\n        if (val instanceof Array) {\n          for (let i = 0; i < val.length; i++) {\n            val[i] =\n              ((val == null || isNaN(Number(val[i])) || val[i] === '') && val[i]) || Number(val[i]);\n          }\n        }\n        val = JSON.stringify(val);\n      } else {\n        val = Number(val);\n      }\n      fstr = `${fstr}var ${x} = ${val}; `;\n    });\n  }\n  return fstr;\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfCondition} from '../interface/condition';\nimport {createCondition} from './create-condition';\n\n/**\n * It creates a false AjfCondidion.\n */\nexport function neverCondition(): AjfCondition {\n  return createCondition({condition: 'false'});\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {getCodeIdentifiers} from './expression-utils';\n\nexport function normalizeExpression(\n  formula: string,\n  ancestorsNames: {[prop: string]: number},\n  prefix: number[],\n): string {\n  const ancestorsNameStrings = Object.keys(ancestorsNames);\n  const tokens = getCodeIdentifiers(formula);\n  tokens.forEach((t: any) => {\n    if (ancestorsNameStrings.indexOf(t) > -1) {\n      formula = formula.replace(\n        new RegExp(`\\\\b${t}\\\\b`, 'g'),\n        `${t}__${prefix.slice(ancestorsNames[t]).join('__')}`,\n      );\n    }\n  });\n  return formula;\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport {AjfContext} from '@ajf/core/common';\n\nimport {getContextString} from './get-context-string';\n\nlet cachedContext: any = {};\nlet cachedContextString = '{}';\n\nexport function validateExpression(str: string, context?: AjfContext): boolean {\n  if (context === cachedContext) {\n    console.log('cache hit');\n  } else {\n    cachedContext = context;\n    cachedContextString = getContextString(context);\n  }\n  let ctx = cachedContextString;\n  try {\n    let f = new Function(`${ctx}${str}`);\n    f();\n    f = <any>null;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nexport * from './context';\nexport * from './error';\nexport * from './interface/condition';\nexport * from './interface/formula';\nexport * from './interface/validation-function';\nexport * from './serializers/condition-serializer';\nexport * from './serializers/formula-serializer';\nexport * from './utils/always-condition';\nexport * from './utils/create-condition';\nexport * from './utils/create-formula';\nexport * from './utils/expression-utils';\nexport * from './utils/get-context-string';\nexport * from './utils/never-condition';\nexport * from './utils/normalize-expression';\nexport * from './utils/validate-expression';\n","/**\n * @license\n * Copyright (C) Gnucoop soc. coop.\n *\n * This file is part of the Advanced JSON forms (ajf).\n *\n * Advanced JSON forms (ajf) is free software: you can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the License,\n * or (at your option) any later version.\n *\n * Advanced JSON forms (ajf) is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero\n * General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Advanced JSON forms (ajf).\n * If not, see http://www.gnu.org/licenses/.\n *\n */\n\nexport * from './public-api';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}